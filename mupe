#!/usr/bin/perl

#
# MUltiPath Estimater
#
# Author:
#   Thomas Liske <liske@ibh.de>
#
# Copyright Holder:
#   2010 (C) IBH IT-Service GmbH [http://micky.ibh.net/~liske/mupe/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

=head1 NAME

mupe - MUltiPath Estimator

=head1 SYNOPSIS

mupe <options>

 Options:
   -f <output format>              graph output format (default: png)
   -i <file.pcap>                  pcap input file (required)
   -l <linetype>                   linetype (default: points pt 1)
   -s <BSSID subst>                perl regex subst on BSSIDs (default: s/.$/0/)
   -t <time>                       timeslot size in seconds (default: 2)

   --help                          brief help message

=head1 OPTIONS

=over 8

=item B<-i <file.pcap>>

Input pcap file with Radiotap headers.

=item B<-l <linetype>>

Linetype to plot signal lines, see gnuplot(1) (default: I<points pt 1>).

=item B<-s <BSSID subst>>

Perl regex to apply on BSSID hex strings before processing, the default value zeros the last nibble (default: I<s/.$/0/>).

=item B<-t <time>>

Sets timeslot size in seconds (default: I<2>).

=item B<--help>

Print a brief help message and exits.


=back

=head1 DESCRIPTION

=cut

use strict;
use warnings;
use Getopt::Std;
use Pod::Usage;
use Net::Pcap;
use Chart::Gnuplot;
use Statistics::Descriptive;
use POSIX;
use List::Util qw(min max sum);
use File::Basename;

$|++;

use constant {
    # Taken from wireshark 1.3.4 (epan/dissectors/packet-radiotap.c)
    IEEE80211_RADIOTAP_TSFT => 0,
    IEEE80211_RADIOTAP_FLAGS => 1,
    IEEE80211_RADIOTAP_RATE => 2,
    IEEE80211_RADIOTAP_CHANNEL => 3,
    IEEE80211_RADIOTAP_FHSS => 4,
    IEEE80211_RADIOTAP_DBM_ANTSIGNAL => 5,
    IEEE80211_RADIOTAP_DBM_ANTNOISE => 6,
    IEEE80211_RADIOTAP_LOCK_QUALITY => 7,
    IEEE80211_RADIOTAP_TX_ATTENUATION => 8,
    IEEE80211_RADIOTAP_DB_TX_ATTENUATION => 9,
    IEEE80211_RADIOTAP_DBM_TX_POWER => 10,
    IEEE80211_RADIOTAP_ANTENNA => 11,
    IEEE80211_RADIOTAP_DB_ANTSIGNAL => 12,
    IEEE80211_RADIOTAP_DB_ANTNOISE => 13,
    IEEE80211_RADIOTAP_RX_FLAGS => 14,
    IEEE80211_RADIOTAP_XCHANNEL => 18,
    IEEE80211_RADIOTAP_EXT => 31,
};

my %IEEE80211_RADIOTAP_FIELDLEN = (
    0 => 8,
    1 => 1,
    2 => 1,
    3 => 4,
    4 => 2,
    5 => 1,
    6 => 1,
);

my %opts;
getopts('f:s:l:t:i:', \%opts);

HELP_MESSAGE() unless(defined($opts{'i'}));

$opts{'l'} = 'points pt 1' unless(defined($opts{'l'}));
$opts{'s'} = 's/.$/0/' unless(defined($opts{'s'}));
$opts{'f'} = 'png' unless(defined($opts{'f'}));

my $min_samples = 10;
my $chart_dim = '3,2';

sub HELP_MESSAGE {
    pod2usage(1);
}

my $tfactor = 2;
if(defined($opts{'t'})) {
    $! = 0;
    ($tfactor) = POSIX::strtod($opts{'t'});

    die "Timeslot size must be float and greater than zero!\n" unless($tfactor > 0 && $! == 0);
}

my $pcap_t;
my $err;
my @colors = qw(brown green blue);

die "'$opts{i}' not readable!\n" unless(-r $opts{'i'});
$pcap_t = Net::Pcap::open_offline($opts{'i'}, \$err);
die "Could not open libpcap: $err\n" unless(defined($pcap_t));

$opts{'i'} = basename($opts{'i'});

my $last_tsamp = 0;
my %beacons;
my %stas;
my %preq;
my %pres;

sub track_beacon {
    my ($tstamp, $bssid, $freq, $bssid2, $ts, $bi) = @_;

    if(exists($beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2})) {
	my $sc = $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2};

	# tolerate up to 0.03% clock deviation
	my $d = $bi/1000000;
	while($sc->{'tstamp'} + $d < $tstamp - $bi*3e-8) {
	    $d += $bi/1000000;
	
	    $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2} = Statistics::Descriptive::Full->new()
		unless(exists($beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}));
	    $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}->add_data($sc->{'tstamp'} + $d);
	}

	warn "bssid $bssid2 has changed beacon interval from $beacons{$freq}->{$bssid}->{beacon}->{$bssid2}->{bi} to ${bi}Âµs\n" if($beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'bi'} != $bi);
    }
    else {
	$beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'bi'} = $bi;
    }

    $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'tstamp'} = $tstamp;
    $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'ts'} = $ts;
}

sub push_beacon {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    my ($tstamp, $bssid, $freq, $bssid2, $signal, $noise) = @_;

    unless(exists($beacons{$freq}->{$bssid}->{'tstamps'})) {
	$beacons{$freq}->{$bssid}->{'tstamps'} = Statistics::Descriptive::Full->new();
	$beacons{$freq}->{$bssid}->{'signals'} = Statistics::Descriptive::Full->new();
    }

    $beacons{$freq}->{$bssid}->{'tstamps'} -> add_data($tstamp);
    $beacons{$freq}->{$bssid}->{'signals'} -> add_data($signal);

    $beacons{$freq}->{$bssid}->{'counter'} -> {$bssid2}++;
}

sub push_data {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    my ($tstamp, $src, $rt_frequency, $bssid, $rt_ssi_signal, $rt_ssi_noise) = @_;

    unless(exists($stas{$src}->{$rt_frequency}->{$bssid})) {
	$stas{$src}->{$rt_frequency}->{$bssid}->{'tstamps'} = Statistics::Descriptive::Full->new();
	$stas{$src}->{$rt_frequency}->{$bssid}->{'signals'} = Statistics::Descriptive::Full->new();
    }

    $stas{$src}->{$rt_frequency}->{$bssid}->{'tstamps'} -> add_data($tstamp);
    $stas{$src}->{$rt_frequency}->{$bssid}->{'signals'} -> add_data($rt_ssi_signal);
}

sub process_pkt {
    my($arg, $hdr, $pkt) = @_;

    # decode Radiotap header
    my ($it_version, $it_pad, $it_len, $it_present) = unpack('CCSL', $pkt);
    my $offset = 8;
    my $it_presence = $it_present;

    my $rt_frequency;
    my $rt_ssi_signal;
    my $rt_ssi_noise;

    while($it_present & (1 << IEEE80211_RADIOTAP_EXT)) {
	$it_present = unpack('L', substr($pkt, $offset));
	$it_presence |= $it_present << 32 * ($offset-4)/4;
	$offset += 4;
    }

    ### XXX crude hack XXX ###
    foreach my $fkey (sort keys %IEEE80211_RADIOTAP_FIELDLEN) {
	if(($fkey == IEEE80211_RADIOTAP_CHANNEL) && ($it_presence & (1 << $fkey))) {
	    $rt_frequency = unpack('v', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTSIGNAL) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_signal = unpack('c', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTNOISE) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_noise = unpack('c', substr($pkt, $offset));
	}

	if($it_presence & (1 << $fkey)) {
	    $offset += $IEEE80211_RADIOTAP_FIELDLEN{$fkey};
	}
    }
    ### XXX /crude hack XXX ###

    # decode IEEE 802.11 Beacon frame
    my ($type, $flags, $duration, $dst, $src, $bssid, $seq) = unpack('CCna6a6a6v', substr($pkt, $it_len));

    $dst = unpack('H12', $dst);
    $src = unpack('H12', $src);

    # beacon frame
    if($type == 0x80) {
	my ($ts_low, $ts_high, $bi) = unpack('VVv', substr($pkt, $it_len + 0x18));

	$bssid = unpack('H12', $bssid);
	$seq >>= 4 if(defined($seq));
	my $ts = $ts_high << 32 | $ts_low;
	$bi *= 1024;

	warn "Unexpected dst=$dst in beacon of bssid=$bssid!\n" unless($dst eq 'ffffffffffff');
	warn "Unexpected src<>bssid ($src<>$bssid) in beacon!\n" unless($src eq $bssid);

	$bssid =~ s/^(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})$/$1:$2:$3:$4:$5:$6/;

	my $tstamp = $hdr->{tv_sec}+$hdr->{tv_usec}/1000000;
	my $bssid2 = $bssid;
	eval("\$bssid =~ $opts{'s'};") if(defined($opts{'s'}) && $opts{'s'});

	track_beacon($tstamp, $bssid, $rt_frequency, $bssid2, $ts, $bi);
	push_beacon($tstamp, $bssid, $rt_frequency, $bssid2, $rt_ssi_signal, $rt_ssi_noise);

	print "b";
    }
    # probe request/response frame
    elsif($type == 0x40 || $type == 0x50) {
    }
    # data frame
    elsif(($type & 0x0f) == 8 && !($src =~ /0[01]0000000000/)) {
	$bssid = unpack('H12', $bssid);
	$seq >>= 4 if(defined($seq));

	$src =~ s/^(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})$/$1:$2:$3:$4:$5:$6/;
	$bssid =~ s/^(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})$/$1:$2:$3:$4:$5:$6/;

	my $tstamp = $hdr->{tv_sec}+$hdr->{tv_usec}/1000000;

	push_data($tstamp, $src, $rt_frequency, $bssid, $rt_ssi_signal, $rt_ssi_noise);

	print "d";
    }
}

# Process packets
print "Reading pcap file:\n";
Net::Pcap::loop($pcap_t, -1, \&process_pkt, 0);
print "\n";

sub write_stats {
    my ($fh, $name, $sd) = @_;

    printf $fh "%24s = %s\n", "MEAN($name)", $sd->mean();
    printf $fh "%24s = %s\n", "MODE($name)", $sd->mode();
    printf $fh "%24s = %s\n", "Q0($name)", $sd->quantile(0);
    printf $fh "%24s = %s\n", "Q1($name)", $sd->quantile(1);
    printf $fh "%24s = %s\n", "Q2($name)", $sd->quantile(2);
    printf $fh "%24s = %s\n", "Q3($name)", $sd->quantile(3);
    printf $fh "%24s = %s\n", "Q4($name)", $sd->quantile(4);
    printf $fh "%24s = %s\n", "SKEWNESS($name)", $sd->skewness()
     if(defined($sd->skewness()));
    printf $fh "%24s = %s\n", "KURTOSIS($name)", $sd->kurtosis()
     if(defined($sd->kurtosis()));
    print $fh "\n";
}

sub build_trend_jitter {
    my ($tfn, $subtitle, $data) = @_;

    my $fn = sprintf $tfn, 'signal-trend', $opts{'f'};
    unlink($fn);

    my %trend;
    my @tslots;
    my $i = -1;
    foreach my $tstamp ($data->{'tstamps'}->get_data()) {
	$i++;
	my $t = int($tstamp) - (int($tstamp) % $tfactor);
	push(@tslots, $t) unless($#tslots >= 0 && $tslots[$#tslots] == $t);

	$trend{'signals'}->{$t} = Statistics::Descriptive::Full->new() unless(exists($trend{'signals'}->{$t}));
	$trend{'signals'}->{$t}->add_data(${$data->{'signals'}->{'data'}}[$i]);
    }

    my @ds;
    my %data = (
	'min' => 'MIN(signal)',
	'mean' => 'MEAN(signal)',
	'max' => 'MAX(signal)',
    );

    my %ydata;
    my $sr = Statistics::Descriptive::Full->new();
    foreach my $t (@tslots) {
	foreach my $col (sort keys %data) {
	    push(@{$ydata{$col}}, $trend{'signals'}->{$t}->$col);
	}

	$sr -> add_data($trend{'signals'}->{$t}->sample_range());
    }

    open(HD, sprintf ">$tfn", 'signal-trend', 'txt');
    &write_stats(*HD, 'signal', $data->{'signals'});
    foreach my $col (sort keys %data) {
	my $color = shift(@colors);
	push(@colors, $color);

	my $stat = Statistics::Descriptive::Full->new();
	$stat -> add_data(@{$ydata{$col}});

	&write_stats(*HD, $data{$col}, $stat);
	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => $ydata{$col},
		style => $opts{'l'},
		linetype => 1,
		color => $color,
		title => $data{$col},
		using => '1:2'
	    ),
	    Chart::Gnuplot::DataSet->new(
		func => $stat->mean(),
		style => 'lines',
		linetype => 3,
		color => $color,
		title => "MEAN[$data{$col}]",
		width => 5,
	    ),
	);
    }
    close(HD);

    Chart::Gnuplot->new(
	output => $fn,
	title => "beacon frame signal trend\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dBm',
	imagesize => $chart_dim,
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(@ds);


    $fn = sprintf $tfn, 'signal-jitter', $opts{'f'};
    unlink($fn);
    my @sr = $sr->get_data();
    Chart::Gnuplot->new(
	output => $fn,
	title => "beacon frame signal jitter\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dB',
	imagesize => $chart_dim,
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@tslots,
	    ydata => \@sr,
	    style => $opts{'l'},
	    linetype => 1,
	    color => 'red',
	    title => 'SR(signal)',
	    using => '1:2'
	),
	Chart::Gnuplot::DataSet->new(
	    func => $sr->mean(),
	    style => 'lines',
	    linetype => 2,
	    color => 'red',
	    title => "MEAN[SR(signal)]",
	    width => 5,
	),
    );
    open(HD, sprintf ">$tfn", 'signal-jitter', 'txt');
    &write_stats(*HD, 'jitter', $sr);
    close(HD);

    return (
	'signal-trend' => 'beacon frame signal trend',
	'signal-jitter' => 'beacon frame signal jitter',
    );
}

sub build_distri {
    my ($tfn, $subtitle, $data) = @_;

    ### Signal Distribution ###
    my %distri_signals;
    foreach my $signal ($data->{'signals'}->get_data()) {
	$distri_signals{$signal}++;
    }

    open(HDISTRI, sprintf(">$tfn", 'signal-distri', 'txt')) || die "Could not open file: $?\n";
    print HDISTRI "#signal (dBm), count\n";
    my @distri_signal;
    my @distri_scount;
    foreach my $signal (sort {$a <=> $b} keys %distri_signals) {
	print HDISTRI "$signal, $distri_signals{$signal}\n";
	push(@distri_signal, $signal);
	push(@distri_scount, $distri_signals{$signal}*100/$data->{'signals'}->count());
    }
    close(HDISTRI);

    my $fn = sprintf $tfn, 'signal-distri', $opts{'f'};
    unlink($fn);
    Chart::Gnuplot->new(
	output => $fn,
	title => "beacon frame signal distribution\\n$subtitle",
	xlabel => 'dBm',
	ylabel => '%',
	xtics => \@distri_signal,
	xrange => [-96,-20],
	yrange => [0,100],
	imagesize => $chart_dim,
	grid => {
	    width => 1.
	},
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@distri_signal,
	    ydata => \@distri_scount,
	    style => 'boxes',
	    fill => '1 border -1',
	    linetype => 1,
	    using => '1:2'
	)
    );

    return (
	'signal-distri' => 'beacon frame signal distribution',
    );
}

sub build_losses {
    my ($tfn, $subtitle, $data) = @_;

    ### Beacon Losses ###
    my @ds;
    my $z = 0;
    my $max = 1;
    open(HD, sprintf ">$tfn", 'beacon-losses', 'txt');
    my @bssid2 = sort keys %{$data->{'losses'}};
    foreach my $bssid2 (@bssid2) {
	$z++;
	print HD "$bssid2\n";
	print HD " # beacons = ".$data->{'counter'}->{$bssid2}."\n";
	print HD " # missing = ".$data->{'losses'}->{$bssid2}->count()."\n";
	printf HD " loss rate = %.2f%%\n\n", ($data->{'losses'}->{$bssid2}->count() * 100 / $data->{'counter'}->{$bssid2});

	my %data;
	foreach my $ts ($data->{'losses'}->{$bssid2}->get_data()) {
	    $data{ int($ts) - (int($ts) % $tfactor) }++;
	}

	my @tslots;
	my @losses;
	my @bssids;
	foreach my $tstamp ($data->{'tstamps'}->get_data()) {
	    my $ts = int($tstamp) - (int($tstamp) % $tfactor);

	    unless($#tslots >= 0 && $tslots[$#tslots] == $ts) {
		push(@tslots, $ts) ;
		push(@bssids, $z);
		if(exists($data{$ts})) {
		    push(@losses, $data{$ts});
		    $max = $data{$ts} + 1 if($max <= $data{$ts});
		}
		else {
		    push(@losses, 0);
		}
	    }
        }

	my $color = shift(@colors);
	push(@colors, $color);

	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => \@bssids,
		zdata => \@losses,
		style => 'impulses',
		width => 5,
		linetype => 1,
		color => $color,
		title => $bssid2,
		using => '1:2:3'
	    ),
	);
    }
    close(HD);

    if($#ds >= 0) {
	my $fn = sprintf $tfn, 'beacon-losses', $opts{'f'};
	unlink($fn);
	Chart::Gnuplot->new(
	    output => $fn,
	    title => "beacon frame losses\\n$subtitle",
	    xlabel => 'timeslot',
#		xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	    ylabel => 'bssid',
	    yrange => [0.5,$z+0.5],
	    ytics => undef,
	    zrange => [0,$max],
	    ztics => [0..$max],
	    xyplane => 'at 0',
	    imagesize => $chart_dim,
	    grid => {
		width => 1.
	    },
	    timefmt => '"%s"',
	    xdata => 'time',
	    bg => 'white',
	)->plot3d(@ds);

	return (
	    'beacon-losses' => 'beacon frame losses',
	);
    }

    return ();
}


sub build_sta_trend_jitter {
    my ($tfn, $subtitle, $data) = @_;

    my $fn = sprintf $tfn, 'signal-trend', $opts{'f'};
    unlink($fn);

    my %trend;
    my @tslots;
    my $sc = Statistics::Descriptive::Full->new();
    foreach my $freq (keys %{$data}) {
	foreach my $bssid (keys %{$data->{$freq}}) {
	    my $i = -1;

	    $sc->add_data(@{$data->{$freq}->{$bssid}->{'signals'}->{'data'}});
	    foreach my $tstamp ($data->{$freq}->{$bssid}->{'tstamps'}->get_data()) {
		$i++;
		my $t = int($tstamp) - (int($tstamp) % $tfactor);
		push(@tslots, $t) unless($#tslots >= 0 && $tslots[$#tslots] == $t);

		$trend{'signals'}->{$t} = Statistics::Descriptive::Full->new() unless(exists($trend{'signals'}->{$t}));
		$trend{'signals'}->{$t}->add_data(${$data->{$freq}->{$bssid}->{'signals'}->{'data'}}[$i]);
	    }
	}
    }

    if($sc->count() < $min_samples) {
	print "  ignoring - less than $min_samples samples\n";
	return ();
    }

    my @ds;
    my %data = (
	'min' => 'MIN(signal)',
	'mean' => 'MEAN(signal)',
	'max' => 'MAX(signal)',
    );

    my %ydata;
    my $sr = Statistics::Descriptive::Full->new();
    foreach my $t (@tslots) {
	foreach my $col (sort keys %data) {
	    push(@{$ydata{$col}}, $trend{'signals'}->{$t}->$col);
	}

	$sr -> add_data($trend{'signals'}->{$t}->sample_range());
    }

    open(HD, sprintf ">$tfn", 'signal-trend', 'txt');
    &write_stats(*HD, 'signal', $sc);
    foreach my $col (sort keys %data) {
	my $color = shift(@colors);
	push(@colors, $color);

	my $stat = Statistics::Descriptive::Full->new();
	$stat -> add_data(@{$ydata{$col}});

	&write_stats(*HD, $data{$col}, $stat);
	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => $ydata{$col},
		style => $opts{'l'},
		linetype => 1,
		color => $color,
		title => $data{$col},
		using => '1:2'
	    ),
	    Chart::Gnuplot::DataSet->new(
		func => $stat->mean(),
		style => 'lines',
		linetype => 3,
		color => $color,
		title => "MEAN[$data{$col}]",
		width => 5,
	    ),
	);
    }
    close(HD);

    Chart::Gnuplot->new(
	output => $fn,
	title => "data frame signal trend\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dBm',
	imagesize => $chart_dim,
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(@ds);


    $fn = sprintf $tfn, 'signal-jitter', $opts{'f'};
    unlink($fn);
    my @sr = $sr->get_data();
    Chart::Gnuplot->new(
	output => $fn,
	title => "data frame signal jitter\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dB',
	imagesize => $chart_dim,
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@tslots,
	    ydata => \@sr,
	    style => $opts{'l'},
	    linetype => 1,
	    color => 'red',
	    title => 'SR(signal)',
	    using => '1:2'
	),
	Chart::Gnuplot::DataSet->new(
	    func => $sr->mean(),
	    style => 'lines',
	    linetype => 2,
	    color => 'red',
	    title => "MEAN[SR(signal)]",
	    width => 5,
	),
    );
    open(HD, sprintf ">$tfn", 'signal-jitter', 'txt');
    &write_stats(*HD, 'jitter', $sr);
    close(HD);

    return (
	'signal-trend' => 'data frame signal trend',
	'signal-jitter' => 'data frame signal jitter',
    );
}

sub build_sta_distri {
    my ($tfn, $subtitle, $data) = @_;

    ### STA Signal Distribution ###
    my %distri_signals;
    my $count;
    foreach my $freq (keys %{$data}) {
	foreach my $bssid (keys %{$data->{$freq}}) {
	    foreach my $signal ($data->{$freq}->{$bssid}->{'signals'}->get_data()) {
		$distri_signals{$signal}++;
		$count++;
	    }
	}
    }

    return () if($count < $min_samples);

    open(HDISTRI, sprintf(">$tfn", 'signal-distri', 'txt')) || die "Could not open file: $?\n";
    print HDISTRI "#signal (dBm), count\n";
    my @distri_signal;
    my @distri_scount;
    foreach my $signal (sort {$a <=> $b} keys %distri_signals) {
	print HDISTRI "$signal, $distri_signals{$signal}\n";
	push(@distri_signal, $signal);
	push(@distri_scount, $distri_signals{$signal}*100/$count);
    }
    close(HDISTRI);

    my $fn = sprintf $tfn, 'signal-distri', $opts{'f'};
    unlink($fn);
    Chart::Gnuplot->new(
	output => $fn,
	title => "data frame signal distribution\\n$subtitle",
	xlabel => 'dBm',
	ylabel => '%',
	xtics => \@distri_signal,
	xrange => [-96,-20],
	yrange => [0,100],
	imagesize => $chart_dim,
	grid => {
	    width => 1.
	},
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@distri_signal,
	    ydata => \@distri_scount,
	    style => 'boxes',
	    fill => '1 border -1',
	    linetype => 1,
	    using => '1:2'
	)
    );

    return (
	'signal-distri' => 'data frame signal distribution',
    );
}

my $fn = $opts{'i'};
$fn =~ s/\.pcap$//;
$fn .= ".html";

open(HHTML, ">$fn") || die "Could not open output file '$fn': $!\n";
print HHTML <<BOH;
<html>
<header>
<title>mupe: $opts{i}</title>
<script language="javascript"> 
    function toggle(elName) {
	var ele = document.getElementById(elName);
	if(ele.style.display == "block") {
	    ele.style.display = "none";
	}
	else {
	    ele.style.display = "block";
	}
}
</script>
</header>
<body>
<h1>mupe: $opts{i}</h1>
BOH

print "\nGenerating beacon frame graphs:\n";
print HHTML "<h2>Beacon frame graphs</h2>\n";
foreach my $freq (keys %beacons) {
    foreach my $bssid (sort keys %{$beacons{$freq}}) {
	my $count = $beacons{$freq}->{$bssid}->{'tstamps'}->{'count'};
	my $ts_min = $beacons{$freq}->{$bssid}->{'tstamps'}->{'min'};
	my $ts_max = $beacons{$freq}->{$bssid}->{'tstamps'}->{'max'};

	if($count < $min_samples) {
	    print " ignoring BSSID $bssid @ ${freq}kHz - less than $min_samples samples\n";
	    next;
	}

	print " BSSID $bssid @ $freq kHz\n";
	foreach my $bssid2 (sort keys %{$beacons{$freq}->{$bssid}->{'counter'}}) {
	    print "  $bssid2 has $beacons{$freq}->{$bssid}->{counter}->{$bssid2}";
	    print " (", $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}->count()," lost)"
		if(exists($beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}));
	    print " beacons\n";
	}

	my $tfn = $opts{'i'};
	$tfn =~ s/\.pcap$//;
	$tfn .= ".BSSID-$bssid-${freq}kHz.%s.%s";
	$tfn =~ s/://g;
	my $subtitle = "$opts{i} [BSSID = $bssid, f = ${freq}kHz, tslot = ${tfactor}s]";

	my %links = (
	    build_trend_jitter($tfn, $subtitle, $beacons{$freq} -> {$bssid}),
	    build_distri($tfn, $subtitle,  $beacons{$freq} -> {$bssid}),
	    build_losses($tfn, $subtitle,  $beacons{$freq} -> {$bssid}),
	);

	print HHTML "<h3>$bssid</h3>";
	foreach my $k (sort {$links{$a} cmp $links{$b}} keys %links) {
	    my $png = sprintf($tfn, $k, 'png');
	    my $txt = sprintf($tfn, $k, 'txt');

	    print HHTML "<li><a href=\"javascript:toggle('$txt')\">$links{$k}</a>\n";
	    print HHTML "<div id=\"$txt\" style=\"display: none;\">\n";
	    print HHTML "<p><a href=\"$png\"><img src=\"$png\" alt=\"$links{$k}\" border=\"0\" height=\"80%\" width=\"80%\"/></a></p><pre>\n";
	    open(HPRE, $txt);
	    print HHTML join('', <HPRE>);
	    close(HPRE);
	    print HHTML "</pre>\n";
	    print HHTML "</div></li>\n"
	}
	print HHTML "</ul>\n";
    }
}

print "\nGenerating data frame graphs:\n";
print HHTML "<h2>Data frame graphs</h2>\n";
foreach my $src (sort keys %stas) {
    print " STA $src\n";

    my $tfn = $opts{'i'};
    $tfn =~ s/\.pcap$//;
    $tfn .= ".STA-$src.%s.%s";
    $tfn =~ s/://g;
    my $subtitle = "$opts{i} [STA = $src, tslot = ${tfactor}s]";

    my %links = (
	build_sta_trend_jitter($tfn, $subtitle, $stas{$src}),
	build_sta_distri($tfn, $subtitle, $stas{$src}),
    );

    print HHTML "<h3>$src</h3><ul>";
    foreach my $k (sort {$links{$a} cmp $links{$b}} keys %links) {
	my $png = sprintf($tfn, $k, 'png');
	my $txt = sprintf($tfn, $k, 'txt');

	print HHTML "<li><a href=\"javascript:toggle('$txt')\">$links{$k}</a>\n";
	print HHTML "<div id=\"$txt\" style=\"display: none;\">\n";
	print HHTML "<p><a href=\"$png\"><img src=\"$png\" alt=\"$links{$k}\" border=\"0\" height=\"80%\" width=\"80%\"/></a></p><pre>\n";
	open(HPRE, $txt);
	print HHTML join('', <HPRE>);
	close(HPRE);
	print HHTML "</pre>\n";
	print HHTML "</div></li>\n"
    }
    print HHTML "</ul>\n";
}

print HHTML <<EOH;
</body>
</html>
EOH
