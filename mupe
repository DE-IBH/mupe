#!/usr/bin/perl

#
# MUltiPath Estimater
#
# Author:
#   Thomas Liske <liske@ibh.de>
#
# Copyright Holder:
#   2010 (C) IBH IT-Service GmbH [http://micky.ibh.net/~liske/mupe/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

=head1 NAME

mupe - MUltiPath Estimator

=head1 SYNOPSIS

mupe <options>

 Options:
   -f <output format>              graph output format (default: png)
   -i <file.pcap>                  pcap input file (required)
   -l <linetype>                   linetype (default: points pt 1)
   -s <BSSID subst>                perl regex subst on BSSIDs (default: s/.$/0/)
   -t <time>                       timeslot size in seconds (default: 2)

   --help                          brief help message

=head1 OPTIONS

=over 8

=item B<-i <file.pcap>>

Input pcap file with Radiotap headers.

=item B<-l <linetype>>

Linetype to plot signal lines, see gnuplot(1) (default: I<points pt 1>).

=item B<-s <BSSID subst>>

Perl regex to apply on BSSID hex strings before processing, the default value zeros the last nibble (default: I<s/.$/0/>).

=item B<-t <time>>

Sets timeslot size in seconds (default: I<2>).

=item B<--help>

Print a brief help message and exits.


=back

=head1 DESCRIPTION

=cut

use strict;
use warnings;
use Getopt::Std;
use Pod::Usage;
use Net::Pcap;
use DBI;
use Chart::Gnuplot;
use POSIX;
use List::Util qw(min max sum);
use File::Basename;

$|++;

use constant {
    # Taken from wireshark 1.3.4 (epan/dissectors/packet-radiotap.c)
    IEEE80211_RADIOTAP_TSFT => 0,
    IEEE80211_RADIOTAP_FLAGS => 1,
    IEEE80211_RADIOTAP_RATE => 2,
    IEEE80211_RADIOTAP_CHANNEL => 3,
    IEEE80211_RADIOTAP_FHSS => 4,
    IEEE80211_RADIOTAP_DBM_ANTSIGNAL => 5,
    IEEE80211_RADIOTAP_DBM_ANTNOISE => 6,
    IEEE80211_RADIOTAP_LOCK_QUALITY => 7,
    IEEE80211_RADIOTAP_TX_ATTENUATION => 8,
    IEEE80211_RADIOTAP_DB_TX_ATTENUATION => 9,
    IEEE80211_RADIOTAP_DBM_TX_POWER => 10,
    IEEE80211_RADIOTAP_ANTENNA => 11,
    IEEE80211_RADIOTAP_DB_ANTSIGNAL => 12,
    IEEE80211_RADIOTAP_DB_ANTNOISE => 13,
    IEEE80211_RADIOTAP_RX_FLAGS => 14,
    IEEE80211_RADIOTAP_XCHANNEL => 18,
    IEEE80211_RADIOTAP_EXT => 31,
};

my %IEEE80211_RADIOTAP_FIELDLEN = (
    0 => 8,
    1 => 1,
    2 => 1,
    3 => 4,
    4 => 2,
    5 => 1,
    6 => 1,
);

my %opts;
getopts('f:s:l:t:i:', \%opts);

HELP_MESSAGE() unless(defined($opts{'i'}));

$opts{'l'} = 'points pt 1' unless(defined($opts{'l'}));
$opts{'s'} = 's/.$/0/' unless(defined($opts{'s'}));
$opts{'f'} = 'png' unless(defined($opts{'f'}));

sub HELP_MESSAGE {
    pod2usage(1);
}

my $tfactor = 2;
if(defined($opts{'t'})) {
    $! = 0;
    ($tfactor) = POSIX::strtod($opts{'t'});

    die "Timeslot size must be float and greater than zero!\n" unless($tfactor > 0 && $! == 0);
}

my $pcap_t;
my $err;

die "'$opts{i}' not readable!\n" unless(-r $opts{'i'});
$pcap_t = Net::Pcap::open_offline($opts{'i'}, \$err);
die "Could not open libpcap: $err\n" unless(defined($pcap_t));

$opts{'i'} = basename($opts{'i'});

my $dbfn = "$opts{i}.mupe.db";
unlink($dbfn);
unlink("$dbfn-journal");

my $dbh = DBI->connect("dbi:SQLite:dbname=$dbfn","","");
$dbh->do('CREATE TABLE track_beacons (tstamp REAL, bssid CHAR(12), freq INT, PRIMARY KEY (tstamp, bssid, freq))');
$dbh->do('CREATE TABLE beacons (tstamp REAL, bssid CHAR(12), freq INT, signal INT, noise INT, PRIMARY KEY (tstamp, bssid, freq))');

my %beacon_seqs;
my %beacon_tstamp;
my %beacon_otstamp;
my $sth_push_track = $dbh->prepare('INSERT INTO track_beacons (tstamp, bssid, freq) VALUES (?, ?, ?)');
sub track_beacon {
    my ($tstamp, $bssid, $freq, $seq) = @_;

    my $key = "${bssid}_$freq";

    my $fn = $opts{'i'};
    $fn =~ s/\.pcap//;
    $fn .= ".$bssid-${freq}kHz.missing.txt";

    if(exists($beacon_seqs{$key}) && exists($beacon_tstamp{$key})) {
	my $c = ($beacon_seqs{$key} + 1 - $seq) % 0x1000;

	if(($c > 0) && ($c < 50)) {
	    my $d = ($tstamp - $beacon_tstamp{$key}) / $c;
	    my $t = $beacon_tstamp{$key};

	    open(HMISSING, ">>$fn");
	    print HMISSING "$c $t $beacon_seqs{$key} $tstamp $seq\n";
	    close(HMISSING);

	    print '-';
	    while($c--) {
		$sth_push_track->execute($t += $d, $bssid, $freq);
	    }
	}
    }
    else {
	unlink($fn);
    }

    $beacon_tstamp{$key} = $tstamp;
    $beacon_seqs{$key} = $seq % 0x1000;
}

my $last_tsamp = 0;
my $sth_push = $dbh->prepare('INSERT INTO beacons (tstamp, bssid, freq, signal, noise) VALUES (?, ?, ?, ?, ?)');
sub push_beacon {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    $sth_push->execute(@_);
}

sub process_pkt {
    my($arg, $hdr, $pkt) = @_;

    # decode Radiotap header
    my ($it_version, $it_pad, $it_len, $it_present) = unpack('CCSL', $pkt);
    my $offset = 8;
    my $it_presence = $it_present;

    my $rt_frequency;
    my $rt_ssi_signal;
    my $rt_ssi_noise;

    while($it_present & (1 << IEEE80211_RADIOTAP_EXT)) {
	$it_present = unpack('L', substr($pkt, $offset));
	$it_presence |= $it_present << 32 * ($offset-4)/4;
	$offset += 4;
    }

    ### XXX crude hack XXX ###
    foreach my $fkey (sort keys %IEEE80211_RADIOTAP_FIELDLEN) {
	if(($fkey == IEEE80211_RADIOTAP_CHANNEL) && ($it_presence & (1 << $fkey))) {
	    $rt_frequency = unpack('v', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTSIGNAL) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_signal = unpack('c', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTNOISE) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_noise = unpack('c', substr($pkt, $offset));
	}

	if($it_presence & (1 << $fkey)) {
	    $offset += $IEEE80211_RADIOTAP_FIELDLEN{$fkey};
	}
    }
    ### XXX /crude hack XXX ###

    # decode IEEE 802.11 Beacon frame
    my ($type, $flags, $duration, $dst, $src, $bssid, $seq) = unpack('CCna6a6a6v', substr($pkt, $it_len));

    $dst = unpack('H12', $dst);
    $src = unpack('H12', $src);
    $bssid = unpack('H12', $bssid);
    $seq >>= 4 if(defined($seq));

    # filter for beacons
    if($type == 0x80 && $dst eq 'ffffffffffff') {
	my $tstamp = $hdr->{tv_sec}+$hdr->{tv_usec}/1000000;
	eval("\$bssid =~ $opts{'s'};") if(defined($opts{'s'}) && $opts{'s'});

	track_beacon($tstamp, $bssid, $rt_frequency, $seq);
	push_beacon($tstamp, $bssid, $rt_frequency, $rt_ssi_signal, $rt_ssi_noise);

	print ".";
    }
}

sub median(@) {
    my @s = sort {$a <=> $b} @_;
    my $n = $#s;

    if($n % 2) {
	$n++;
	$n /= 2;

	return (($s[$n - 1] + $s[$n]) / 2);
    }

    return $s[$n/2];
}

# Process packets
print "Reading pcap file";
$dbh->begin_work;
Net::Pcap::loop($pcap_t, -1, \&process_pkt, 0);
$dbh->commit;
print "\n";

print "Generating graphs:\n";

my $sth_qry = $dbh->prepare("SELECT CAST((tstamp/$tfactor) AS INT)*$tfactor AS tslot, COUNT(*), MIN(signal), AVG(signal), MAX(signal), MAX(signal) - MIN(signal) FROM beacons WHERE bssid=? AND freq=? GROUP BY tslot");
my $sth_trk = $dbh->prepare("SELECT CAST((tstamp/$tfactor) AS INT)*$tfactor AS tslot, COUNT(*) FROM track_beacons WHERE bssid=? AND freq=? GROUP BY tslot");
my $sth_dis = $dbh->prepare("SELECT signal, COUNT(*) FROM beacons WHERE bssid=? AND freq=? GROUP BY signal");
my $sth_din = $dbh->prepare("SELECT COUNT(*) FROM beacons WHERE bssid=? AND freq=?");
foreach my $row (@{ $dbh->selectall_arrayref('SELECT COUNT(*), bssid, freq, MIN(tstamp), MAX(tstamp) FROM beacons GROUP BY bssid, freq') }) {
    my ($count, $bssid, $freq, $ts_min, $ts_max) = @{$row};
    print " bssid $bssid: $freq kHz, $count beacons\n";

    $sth_qry->execute($bssid, $freq);
    my @tslots;
    my @counts;
    my @jitter;
    my %data;
    foreach my $row (@{ $sth_qry->fetchall_arrayref() }) {
	push(@tslots, ${$row}[0]);
	push(@counts, ${$row}[1]);
	push(@{$data{'MIN(rssi)'}}, ${$row}[2]);
	push(@{$data{'AVG(rssi)'}}, ${$row}[3]);
	push(@{$data{'MAX(rssi)'}}, ${$row}[4]);
	push(@jitter, ${$row}[5]);
    }

    $sth_din->execute($bssid, $freq);
    my $distri_count = ${${ $sth_din->fetchall_arrayref() }[0]}[0];

    my %distri;
    $sth_dis->execute($bssid, $freq);
    foreach my $row (@{ $sth_dis->fetchall_arrayref() }) {
	$distri{${$row}[0]} = ${$row}[1] * 100 / $distri_count;
    }

    my @distri_signals;
    my @distri_counts;
    foreach my $signal (sort {$a <=> $b} keys %distri) {
	push(@distri_signals, $signal);
	push(@distri_counts, $distri{$signal});
    }

    my %trk_losses;
    $sth_trk->execute($bssid, $freq);
    foreach my $row (@{ $sth_trk->fetchall_arrayref() }) {
	$trk_losses{${$row}[0]} = ${$row}[1];
    }

    my @trk_counts;
    foreach my $tslot (@tslots) {
	if(exists($trk_losses{$tslot})) {
	    push(@trk_counts, $trk_losses{$tslot});
	}
	else {
	    push(@trk_counts, 0);
	}
    }

    my $tfn = $opts{'i'};
    $tfn =~ s/\.pcap//;
    $tfn .= ".$bssid-${freq}kHz.%s.%s";

    my $fn = sprintf $tfn, 'details', 'txt';
    open(HDETAILS, ">$fn");
    my $format = "%20s = %s\n";
    printf HDETAILS $format, 'BSSID', $bssid;
    printf HDETAILS $format, 'Freq', "$freq kHz";
    printf HDETAILS $format, 'tslot', "$tfactor";

    print HDETAILS "\n";

    my $subtitle = "$opts{i} [BSSID = $bssid, f = ${freq}kHz, tslot = ${tfactor}s]";

#    my $chart = Chart::Gnuplot->new(
#	output => $fn,
#	title => "$opts{i} [BSSID = $bssid, f = ${freq}kHz, tslot = ${tfactor}s]\\n",
#	imagesize => '2,8',
#	bg => 'white',
 #   );

    $fn = sprintf $tfn, 'trend', $opts{'f'};
    unlink($fn);
    my $chart_trend = Chart::Gnuplot->new(
	output => $fn,
	title => "signal trend\\n$subtitle",
	xlabel => 'timeslot',
	ylabel => 'dBm',
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    );

    $fn = sprintf $tfn, 'jitter', $opts{'f'};
    unlink($fn);
    my $chart_jitter = Chart::Gnuplot->new(
	output => $fn,
	title => "signal jitter: $subtitle",
	xlabel => 'timeslot',
	ylabel => 'dB',
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    );

    $fn = sprintf $tfn, 'losses', $opts{'f'};
    unlink($fn);
    my @trk_ticks = sort {$a <=> $b} @trk_counts;
    my $chart_losses = Chart::Gnuplot->new(
	output => $fn,
	title => "beacon losses: $subtitle",
	xlabel => 'timeslot',
	ylabel => 'count',
	ytics => \@trk_ticks,
	yrange => [0, max(0, @trk_counts) + 1],
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    );

    $fn = sprintf $tfn, 'distri', $opts{'f'};
    unlink($fn);
    my $chart_distri = Chart::Gnuplot->new(
	output => $fn,
	title => "signal distribution: $subtitle",
	xlabel => 'dBm',
	ylabel => '%',
	xtics => \@distri_signals,
	yrange => [0,100],
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	bg => 'white',
    );

    my @ds;
    my @colors = qw(brown green blue);
    foreach my $col (sort keys %data) {
	my $color = shift(@colors);
	push(@colors, $color);

	my $median = median(@{$data{$col}});
	printf HDETAILS $format, "MEDIAN[$col]", "$median dBm";
	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => $data{$col},
		style => $opts{'l'},
		linetype => 1,
		color => $color,
		title => $col,
		using => '1:2'
	    ),
	    Chart::Gnuplot::DataSet->new(
		func => $median,
		style => 'lines',
		linetype => 2,
		color => $color,
		width => 3,
	    )
	);
    }
    $chart_trend->plot2d(@ds);

    print HDETAILS "\n";

    my $median_jitter = median(@jitter);
    printf HDETAILS $format, "MIN[jitter]", min(@jitter).' dB';
    printf HDETAILS $format, "MEDIAN[jitter]", "$median_jitter dB";
    printf HDETAILS $format, "MAX[jitter]", max(@jitter).' dB';
    $chart_jitter->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@tslots,
	    ydata => \@jitter,
	    style => $opts{'l'},
	    linetype => 1,
	    color => 'red',
	    title => 'jitter',
	    using => '1:2'
	),
	Chart::Gnuplot::DataSet->new(
	    func => $median_jitter,
	    style => 'lines',
	    linetype => 2,
	    color => 'red',
	    width => 3,
	)
    );

    print HDETAILS "\n";

    printf HDETAILS $format, "missing beacons", sum(0, @trk_counts);
    $chart_losses->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@tslots,
	    ydata => \@trk_counts,
	    style => 'impulses',
	    width => 5,
	    linetype => 1,
	    title => 'missing beacons',
	    using => '1:2'
	)
    );

    $chart_distri->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@distri_signals,
	    ydata => \@distri_counts,
	    style => 'impulses',
	    width => 5,
	    linetype => 1,
	    using => '1:2'
	)
    );
}

$dbh->disconnect;
unlink($dbfn);
unlink("$dbfn-journal");
