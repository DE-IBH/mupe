#!/usr/bin/perl

#
# MUltiPath Estimater
#
# Author:
#   Thomas Liske <liske@ibh.de>
#
# Copyright Holder:
#   2010 (C) IBH IT-Service GmbH [http://micky.ibh.net/~liske/mupe/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

=head1 NAME

mupe - MUltiPath Estimator

=head1 SYNOPSIS

mupe <options>

 Options:
   -f <output format>              graph output format (default: png)
   -i <file.pcap>                  pcap input file (required)
   -l <linetype>                   linetype (default: points pt 1)
   -s <BSSID subst>                perl regex subst on BSSIDs (default: s/.$/0/)
   -t <time>                       timeslot size in seconds (default: 2)

   --help                          brief help message

=head1 OPTIONS

=over 8

=item B<-i <file.pcap>>

Input pcap file with Radiotap headers.

=item B<-l <linetype>>

Linetype to plot signal lines, see gnuplot(1) (default: I<points pt 1>).

=item B<-s <BSSID subst>>

Perl regex to apply on BSSID hex strings before processing, the default value zeros the last nibble (default: I<s/.$/0/>).

=item B<-t <time>>

Sets timeslot size in seconds (default: I<2>).

=item B<--help>

Print a brief help message and exits.


=back

=head1 DESCRIPTION

=cut

use strict;
use warnings;
use Getopt::Std;
use Pod::Usage;
use Net::Pcap;
use Chart::Gnuplot;
use Statistics::Descriptive;
use POSIX;
use List::Util qw(min max sum);
use File::Basename;

$|++;

use constant {
    # Taken from wireshark 1.3.4 (epan/dissectors/packet-radiotap.c)
    IEEE80211_RADIOTAP_TSFT => 0,
    IEEE80211_RADIOTAP_FLAGS => 1,
    IEEE80211_RADIOTAP_RATE => 2,
    IEEE80211_RADIOTAP_CHANNEL => 3,
    IEEE80211_RADIOTAP_FHSS => 4,
    IEEE80211_RADIOTAP_DBM_ANTSIGNAL => 5,
    IEEE80211_RADIOTAP_DBM_ANTNOISE => 6,
    IEEE80211_RADIOTAP_LOCK_QUALITY => 7,
    IEEE80211_RADIOTAP_TX_ATTENUATION => 8,
    IEEE80211_RADIOTAP_DB_TX_ATTENUATION => 9,
    IEEE80211_RADIOTAP_DBM_TX_POWER => 10,
    IEEE80211_RADIOTAP_ANTENNA => 11,
    IEEE80211_RADIOTAP_DB_ANTSIGNAL => 12,
    IEEE80211_RADIOTAP_DB_ANTNOISE => 13,
    IEEE80211_RADIOTAP_RX_FLAGS => 14,
    IEEE80211_RADIOTAP_XCHANNEL => 18,
    IEEE80211_RADIOTAP_EXT => 31,
};

my %IEEE80211_RADIOTAP_FIELDLEN = (
    0 => 8,
    1 => 1,
    2 => 1,
    3 => 4,
    4 => 2,
    5 => 1,
    6 => 1,
);

my %opts;
getopts('f:s:l:t:i:', \%opts);

HELP_MESSAGE() unless(defined($opts{'i'}));

$opts{'l'} = 'points pt 1' unless(defined($opts{'l'}));
$opts{'s'} = 's/.$/0/' unless(defined($opts{'s'}));
$opts{'f'} = 'png' unless(defined($opts{'f'}));

sub HELP_MESSAGE {
    pod2usage(1);
}

my $tfactor = 2;
if(defined($opts{'t'})) {
    $! = 0;
    ($tfactor) = POSIX::strtod($opts{'t'});

    die "Timeslot size must be float and greater than zero!\n" unless($tfactor > 0 && $! == 0);
}

my $pcap_t;
my $err;
my @colors = qw(brown green blue);

die "'$opts{i}' not readable!\n" unless(-r $opts{'i'});
$pcap_t = Net::Pcap::open_offline($opts{'i'}, \$err);
die "Could not open libpcap: $err\n" unless(defined($pcap_t));

$opts{'i'} = basename($opts{'i'});

my $last_tsamp = 0;
my %beacons;
sub track_beacon {
    my ($tstamp, $bssid, $freq, $bssid2, $ts, $bi) = @_;

    if(exists($beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2})) {
	my $sc = $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2};

	# tolerate up to 0.03% clock deviation
	my $d = $bi/1000000;
	while($sc->{'tstamp'} + $d < $tstamp - $bi*3e-8) {
	    $d += $bi/1000000;
	
	    $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2} = Statistics::Descriptive::Full->new()
		unless(exists($beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}));
	    $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}->add_data($sc->{'tstamp'} + $d);
	}

	warn "bssid $bssid2 has changed beacon interval from $beacons{$freq}->{$bssid}->{beacon}->{$bssid2}->{bi} to ${bi}Âµs\n" if($beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'bi'} != $bi);
    }
    else {
	$beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'bi'} = $bi;
    }

    $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'tstamp'} = $tstamp;
    $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'ts'} = $ts;
}

sub push_beacon {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    my ($tstamp, $bssid, $freq, $bssid2, $signal, $noise) = @_;

    unless(exists($beacons{$freq}->{$bssid}->{'tstamps'})) {
	$beacons{$freq}->{$bssid}->{'tstamps'} = Statistics::Descriptive::Full->new();
	$beacons{$freq}->{$bssid}->{'signals'} = Statistics::Descriptive::Full->new();
	$beacons{$freq}->{$bssid}->{'noises'} = Statistics::Descriptive::Full->new();
    }

    $beacons{$freq}->{$bssid}->{'tstamps'} -> add_data($tstamp);
    $beacons{$freq}->{$bssid}->{'signals'} -> add_data($signal);
    $beacons{$freq}->{$bssid}->{'noises'} -> add_data($noise);

    $beacons{$freq}->{$bssid}->{'counter'} -> {$bssid2}++;
}

sub process_pkt {
    my($arg, $hdr, $pkt) = @_;

    # decode Radiotap header
    my ($it_version, $it_pad, $it_len, $it_present) = unpack('CCSL', $pkt);
    my $offset = 8;
    my $it_presence = $it_present;

    my $rt_frequency;
    my $rt_ssi_signal;
    my $rt_ssi_noise;

    while($it_present & (1 << IEEE80211_RADIOTAP_EXT)) {
	$it_present = unpack('L', substr($pkt, $offset));
	$it_presence |= $it_present << 32 * ($offset-4)/4;
	$offset += 4;
    }

    ### XXX crude hack XXX ###
    foreach my $fkey (sort keys %IEEE80211_RADIOTAP_FIELDLEN) {
	if(($fkey == IEEE80211_RADIOTAP_CHANNEL) && ($it_presence & (1 << $fkey))) {
	    $rt_frequency = unpack('v', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTSIGNAL) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_signal = unpack('c', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTNOISE) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_noise = unpack('c', substr($pkt, $offset));
	}

	if($it_presence & (1 << $fkey)) {
	    $offset += $IEEE80211_RADIOTAP_FIELDLEN{$fkey};
	}
    }
    ### XXX /crude hack XXX ###

    # decode IEEE 802.11 Beacon frame
    my ($type, $flags, $duration, $dst, $src, $bssid, $seq, $ts_low, $ts_high, $bi) = unpack('CCna6a6a6vVVv', substr($pkt, $it_len));

    $dst = unpack('H12', $dst);

    # filter for beacons
    if($type == 0x80 && $dst eq 'ffffffffffff') {
	$src = unpack('H12', $src);
	$bssid = unpack('H12', $bssid);
	$seq >>= 4 if(defined($seq));
	my $ts = $ts_high << 32 | $ts_low;
	$bi *= 1024;

	$bssid =~ s/^(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})$/$1:$2:$3:$4:$5:$6/;

	my $tstamp = $hdr->{tv_sec}+$hdr->{tv_usec}/1000000;
	my $bssid2 = $bssid;
	eval("\$bssid =~ $opts{'s'};") if(defined($opts{'s'}) && $opts{'s'});

	track_beacon($tstamp, $bssid, $rt_frequency, $bssid2, $ts, $bi);
	push_beacon($tstamp, $bssid, $rt_frequency, $bssid2, $rt_ssi_signal, $rt_ssi_noise);

	print ".";
    }
}

# Process packets
print "Reading pcap file";
Net::Pcap::loop($pcap_t, -1, \&process_pkt, 0);
print "\n";

print "Generating graphs:\n";

sub write_stats() {
    my ($fh, $name, $sd) = @_;

    printf $fh "%24s = %s\n", "MEAN($name)", $sd->mean();
    printf $fh "%24s = %s\n", "MODE($name)", $sd->mode();
    printf $fh "%24s = %s\n", "Q0($name)", $sd->quantile(0);
    printf $fh "%24s = %s\n", "Q1($name)", $sd->quantile(1);
    printf $fh "%24s = %s\n", "Q2($name)", $sd->quantile(2);
    printf $fh "%24s = %s\n", "Q3($name)", $sd->quantile(3);
    printf $fh "%24s = %s\n", "Q4($name)", $sd->quantile(4);
    printf $fh "%24s = %s\n", "SKEWNESS($name)", $sd->skewness()
     if(defined($sd->skewness()));
    printf $fh "%24s = %s\n", "KURTOSIS($name)", $sd->kurtosis()
     if(defined($sd->kurtosis()));
    print $fh "\n";
}

sub build_trend_jitter() {
    my ($tfn, $subtitle, $data) = @_;

    my $fn = sprintf $tfn, 'signal-trend', $opts{'f'};
    unlink($fn);

    my %trend;
    my @tslots;
    my $i = -1;
    foreach my $tstamp ($data->{'tstamps'}->get_data()) {
	$i++;
	my $t = int($tstamp) - (int($tstamp) % $tfactor);
	push(@tslots, $t) unless($#tslots >= 0 && $tslots[$#tslots] == $t);

	foreach my $param (qw(signals noises)) {
	    $trend{$param}->{$t} = Statistics::Descriptive::Full->new() unless(exists($trend{$param}->{$t}));
	    $trend{$param}->{$t}->add_data(${$data->{$param}->{'data'}}[$i]);
	}
    }

    my @ds;
    my %data = (
	'min' => 'MIN(signal)',
	'mean' => 'MEAN(signal)',
	'max' => 'MAX(signal)',
    );

    my %ydata;
    my $sr = Statistics::Descriptive::Full->new();
    foreach my $t (@tslots) {
	foreach my $col (sort keys %data) {
	    push(@{$ydata{$col}}, $trend{'signals'}->{$t}->$col);
	}

	$sr -> add_data($trend{'signals'}->{$t}->sample_range());
    }

    open(HD, sprintf ">$tfn", 'signal-trend', 'txt');
    &write_stats(*HD, 'signal', $data->{'signals'});
    &write_stats(*HD, 'noise', $data->{'noises'});
    foreach my $col (sort keys %data) {
	my $color = shift(@colors);
	push(@colors, $color);

	my $stat = Statistics::Descriptive::Full->new();
	$stat -> add_data(@{$ydata{$col}});

	&write_stats(*HD, $data{$col}, $stat);
	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => $ydata{$col},
		style => $opts{'l'},
		linetype => 1,
		color => $color,
		title => $data{$col},
		using => '1:2'
	    ),
	    Chart::Gnuplot::DataSet->new(
		func => $stat->mean(),
		style => 'lines',
		linetype => 3,
		color => $color,
		title => "MEAN[$data{$col}]",
		width => 5,
	    ),
	);
    }
    close(HD);

    Chart::Gnuplot->new(
	output => $fn,
	title => "signal trend\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dBm',
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(@ds);


    $fn = sprintf $tfn, 'signal-jitter', $opts{'f'};
    unlink($fn);
    my @sr = $sr->get_data();
    Chart::Gnuplot->new(
	output => $fn,
	title => "signal jitter\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dB',
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@tslots,
	    ydata => \@sr,
	    style => $opts{'l'},
	    linetype => 1,
	    color => 'red',
	    title => 'SR(signal)',
	    using => '1:2'
	),
	Chart::Gnuplot::DataSet->new(
	    func => $sr->mean(),
	    style => 'lines',
	    linetype => 2,
	    color => 'red',
	    title => "MEAN[SR(signal)]",
	    width => 5,
	),
    );
    open(HD, sprintf ">$tfn", 'signal-jitter', 'txt');
    &write_stats(*HD, 'jitter', $sr);
    close(HD);
}

sub build_distri() {
    my ($tfn, $subtitle, $data) = @_;

    ### Signal Distribution ###
    my %distri_signals;
    foreach my $signal ($data->{'signals'}->get_data()) {
	$distri_signals{$signal}++;
    }

    open(HDISTRI, sprintf(">$tfn", 'signal-distri', 'txt')) || die "Could not open file: $?\n";
    print HDISTRI "#signal (dBm), count\n";
    my @distri_signal;
    my @distri_scount;
    foreach my $signal (sort {$a <=> $b} keys %distri_signals) {
	print HDISTRI "$signal, $distri_signals{$signal}\n";
	push(@distri_signal, $signal);
	push(@distri_scount, $distri_signals{$signal}*100/$data->{'signals'}->count());
    }
    close(HDISTRI);

    my $fn = sprintf $tfn, 'signal-distri', $opts{'f'};
    unlink($fn);
    Chart::Gnuplot->new(
	output => $fn,
	title => "signal distribution\\n$subtitle",
	xlabel => 'dBm',
	ylabel => '%',
	xtics => \@distri_signal,
	yrange => [0,100],
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@distri_signal,
	    ydata => \@distri_scount,
	    style => 'boxes',
	    width => 5,
	    linetype => 1,
	    using => '1:2'
	)
    );

    ### Noise Distribution ###
    my %distri_noises;
    foreach my $noise ($data->{'noises'}->get_data()) {
	$distri_noises{$noise}++;
    }

    open(HDISTRI, sprintf(">$tfn", 'noise-distri', 'txt')) || die "Could not open file: $?\n";
    print HDISTRI "#noise (dBm), count\n";
    my @distri_noise;
    my @distri_ncount;
    foreach my $noise (sort {$a <=> $b} keys %distri_noises) {
	print HDISTRI "$noise, $distri_noises{$noise}\n";
	push(@distri_noise, $noise);
	push(@distri_ncount, $distri_noises{$noise}*100/$data->{'noises'}->count());
    }
    close(HDISTRI);

    $fn = sprintf $tfn, 'noise-distri', $opts{'f'};
    unlink($fn);
    Chart::Gnuplot->new(
	output => $fn,
	title => "noise distribution\\n$subtitle",
	xlabel => 'dBm',
	ylabel => '%',
	xtics => \@distri_noise,
	yrange => [0,100],
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@distri_noise,
	    ydata => \@distri_ncount,
	    style => 'boxes',
	    width => 5,
	    linetype => 1,
	    using => '1:2'
	)
    );
}

sub build_losses() {
    my ($tfn, $subtitle, $data) = @_;

    ### Beacon Losses ###
    my @ds;
    open(HD, sprintf ">$tfn", 'beacon-losses', 'txt');
    foreach my $bssid2 (keys %{$data->{'losses'}}) {
	print HD "$bssid2\n";
	print HD " # beacons = ".$data->{'counter'}->{$bssid2}."\n";
	print HD " # missing = ".$data->{'losses'}->{$bssid2}->count()."\n\n";

	my %data;
	foreach my $ts ($data->{'losses'}->{$bssid2}->get_data()) {
	    $data{ int($ts) - (int($ts) % $tfactor) }++;
	}

	my @tslots;
	my @losses;
	foreach my $tstamp ($data->{'tstamps'}->get_data()) {
	    my $ts = int($tstamp) - (int($tstamp) % $tfactor);

	    unless($#tslots >= 0 && $tslots[$#tslots] == $ts) {
		push(@tslots, $ts) ;
		push(@losses, $data{$ts});
	    }
        }

	my $color = shift(@colors);
	push(@colors, $color);

	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => \@losses,
		style => 'impulses',
		width => 5,
		linetype => 1,
		color => $color,
		title => $bssid2,
		using => '1:2'
	    ),
	);
    }
    close(HD);

    my $fn = sprintf $tfn, 'beacon-losses', $opts{'f'};
    unlink($fn);
    Chart::Gnuplot->new(
	output => $fn,
	title => "beacon losses\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'count',
	imagesize => '2,2',
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(@ds);
}


foreach my $freq (keys %beacons) {
    foreach my $bssid (sort keys %{$beacons{$freq}}) {
	my $count = $beacons{$freq}->{$bssid}->{'tstamps'}->{'count'};
	my $ts_min = $beacons{$freq}->{$bssid}->{'tstamps'}->{'min'};
	my $ts_max = $beacons{$freq}->{$bssid}->{'tstamps'}->{'max'};

	print " BSSID $bssid @ $freq kHz\n";
	foreach my $bssid2 (sort keys %{$beacons{$freq}->{$bssid}->{'counter'}}) {
	    print "  $bssid2 has $beacons{$freq}->{$bssid}->{counter}->{$bssid2}";
	    print " (", $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}->count()," lost)"
		if(exists($beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}));
	    print " beacons\n";
	}

	my $tfn = $opts{'i'};
	$tfn =~ s/\.pcap$//;
	$tfn .= ".$bssid-${freq}kHz.%s.%s";
	$tfn =~ s/://g;
	my $subtitle = "$opts{i} [BSSID = $bssid, f = ${freq}kHz, tslot = ${tfactor}s]";

	&build_trend_jitter($tfn, $subtitle, $beacons{$freq} -> {$bssid});
	&build_distri($tfn, $subtitle,  $beacons{$freq} -> {$bssid});
	&build_losses($tfn, $subtitle,  $beacons{$freq} -> {$bssid});
    }
}
