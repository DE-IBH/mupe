#!/usr/bin/perl

#
# MUltiPath Estimater
#
# Author:
#   Thomas Liske <liske@ibh.de>
#
# Copyright Holder:
#   2010 (C) IBH IT-Service GmbH [http://micky.ibh.net/~liske/mupe/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

=head1 NAME

mupe - MUltiPath Estimator

=head1 SYNOPSIS

mupe <options>

 Options:
   -i <file.pcap>                  pcap input file (required)
   -t <time>                       timeslot size in seconds (default: 2)

   --help                          brief help message

=head1 OPTIONS

=over 8

=item B<-i <file.pcap>>

Input pcap file with Radiotap headers.

=item B<-t <time>>

Sets timeslot size in seconds (default: 2).

=item B<--help>

Print a brief help message and exits.


=back

=head1 DESCRIPTION

=cut

use strict;
use warnings;
use Getopt::Std;
use Pod::Usage;
use Net::Pcap;
use DBI;
use Chart::Gnuplot;
use POSIX;

$|++;

use constant {
    # Taken from wireshark 1.3.4 (epan/dissectors/packet-radiotap.c)
    IEEE80211_RADIOTAP_TSFT => 0,
    IEEE80211_RADIOTAP_FLAGS => 1,
    IEEE80211_RADIOTAP_RATE => 2,
    IEEE80211_RADIOTAP_CHANNEL => 3,
    IEEE80211_RADIOTAP_FHSS => 4,
    IEEE80211_RADIOTAP_DBM_ANTSIGNAL => 5,
    IEEE80211_RADIOTAP_DBM_ANTNOISE => 6,
    IEEE80211_RADIOTAP_LOCK_QUALITY => 7,
    IEEE80211_RADIOTAP_TX_ATTENUATION => 8,
    IEEE80211_RADIOTAP_DB_TX_ATTENUATION => 9,
    IEEE80211_RADIOTAP_DBM_TX_POWER => 10,
    IEEE80211_RADIOTAP_ANTENNA => 11,
    IEEE80211_RADIOTAP_DB_ANTSIGNAL => 12,
    IEEE80211_RADIOTAP_DB_ANTNOISE => 13,
    IEEE80211_RADIOTAP_RX_FLAGS => 14,
    IEEE80211_RADIOTAP_XCHANNEL => 18,
    IEEE80211_RADIOTAP_EXT => 31,
};

my %IEEE80211_RADIOTAP_FIELDLEN = (
    0 => 8,
    1 => 1,
    2 => 1,
    3 => 4,
    4 => 2,
    5 => 1,
    6 => 1,
);

my %opts;
getopts('t:i:', \%opts);

HELP_MESSAGE() unless(defined($opts{'i'}));

sub HELP_MESSAGE {
    pod2usage(1);
}

my $tfactor = 2;
if(defined($opts{'t'})) {
    $! = 0;
    ($tfactor) = POSIX::strtod($opts{'t'});

    die "Timeslot size must be float and greater than zero!\n" unless($tfactor > 0 && $! == 0);
}

my $pcap_t;
my $err;

die "'$opts{i}' not readable!\n" unless(-r $opts{'i'});
$pcap_t = Net::Pcap::open_offline($opts{'i'}, \$err);
die "Could not open libpcap: $err\n" unless(defined($pcap_t));

unlink("$opts{i}.db") if(-e "$opts{i}.db");

my $dbh = DBI->connect("dbi:SQLite:dbname=$opts{i}.db","","");
$dbh->do('CREATE TABLE beacons (tstamp REAL, bssid CHAR(12), freq INT, signal INT, noise INT, PRIMARY KEY (tstamp, bssid, freq))');
my $sth_push = $dbh->prepare('INSERT INTO beacons (tstamp, bssid, freq, signal, noise) VALUES (?, ?, ?, ?, ?)');

my $last_tsamp = 0;
sub push_db {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    $sth_push->execute(@_);
}

sub process_pkt {
    my($arg, $hdr, $pkt) = @_;

    # decode Radiotap header
    my ($it_version, $it_pad, $it_len, $it_present) = unpack('CCSL', $pkt);
    my $offset = 8;
    my $it_presence = $it_present;

    my $rt_frequency;
    my $rt_ssi_signal;
    my $rt_ssi_noise;

    while($it_present & (1 << IEEE80211_RADIOTAP_EXT)) {
	$it_present = unpack('L', substr($pkt, $offset));
	$it_presence |= $it_present << 32 * ($offset-4)/4;
	$offset += 4;
    }

    ### XXX crude hack XXX ###
    foreach my $fkey (sort keys %IEEE80211_RADIOTAP_FIELDLEN) {
	if(($fkey == IEEE80211_RADIOTAP_CHANNEL) && ($it_presence & (1 << $fkey))) {
	    $rt_frequency = unpack('v', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTSIGNAL) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_signal = unpack('c', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTNOISE) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_noise = unpack('c', substr($pkt, $offset));
	}

	if($it_presence & (1 << $fkey)) {
	    $offset += $IEEE80211_RADIOTAP_FIELDLEN{$fkey};
	}
    }
    ### XXX /crude hack XXX ###

    # decode IEEE 802.11 Beacon frame
    my ($type, $flags, $duration, $dst, $src, $bssid, $seq) = unpack('CCna6a6a6n', substr($pkt, $it_len));

    $dst = unpack('H12', $dst);
    $src = unpack('H12', $src);
    $bssid = unpack('H12', $bssid);

    # filter for beacons
    if($type == 0x80 && $dst eq 'ffffffffffff') {
	push_db($hdr->{tv_sec}+$hdr->{tv_usec}/1000000, $bssid, $rt_frequency, $rt_ssi_signal, $rt_ssi_noise);

	print ".";
    }
}

# Process packets
print "Reading pcap file";
$dbh->begin_work;
Net::Pcap::loop($pcap_t, -1, \&process_pkt, 0);
$dbh->commit;
print "\n";

print "Generating graphs:\n";

my $sth_qry = $dbh->prepare("SELECT CAST((tstamp/$tfactor) AS INT)*$tfactor AS tslot, COUNT(*), MIN(signal), AVG(signal), MAX(signal), MAX(signal) - MIN(signal) FROM beacons WHERE bssid=? AND freq=? GROUP BY tslot");
foreach my $row (@{ $dbh->selectall_arrayref('SELECT COUNT(*), bssid, freq FROM beacons GROUP BY bssid, freq') }) {
    my ($count, $bssid, $freq) = @{$row};
    print " bssid $bssid: $freq kHz, $count beacons\n";

    $sth_qry->execute($bssid, $freq);

    my @tslots;
    my @counts;
    my %data;
    foreach my $row (@{ $sth_qry->fetchall_arrayref() }) {
	push(@tslots, ${$row}[0]);
	push(@counts, ${$row}[1]);
	push(@{$data{'MIN(rssi)'}}, ${$row}[2]);
	push(@{$data{'AVG(rssi)'}}, ${$row}[3]);
	push(@{$data{'MAX(rssi)'}}, ${$row}[4]);
	push(@{$data{'MAX(rssi)-MIN(rssi)'}}, ${$row}[5]);
    }

    unlink("$bssid-$freq.png");
    my $chart = Chart::Gnuplot->new(
	output => "$bssid-$freq.png",
	title => "$opts{i} [BSSID = $bssid, f = ${freq}kHz, tslot = ${tfactor}s]",
	xlabel => 'timeslot (since epoch)',
	ylabel => 'dBm',
	y2label => 'dB',
	y2range => [0, 120],
	imagesize => '2,2',
	bg => 'white',
	grid => {
	    width => 1.
	},
	y2tics => {
	    labels => [0, 10, 20, 30, 40],
	},
    );

    my @ds;
    my @colors = qw(brown green red blue);
    foreach my $col (sort keys %data) {
	my $axes = 'x1y1';
	$axes = 'x1y2' if($col eq 'MAX(rssi)-MIN(rssi)');

	my $color = shift(@colors);
	push(@colors, $color);

	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => $data{$col},
		axes => $axes,
		style => 'lines',
		linetype => 1,
		color => $color,
		title => $col,
	    )
	);
    }

    $chart->plot2d(@ds);
}
