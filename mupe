#!/usr/bin/perl

#
# MUltiPath Estimater
#
# Author:
#   Thomas Liske <liske@ibh.de>
#
# Copyright Holder:
#   2010 (C) IBH IT-Service GmbH [http://micky.ibh.net/~liske/mupe/]
#
# License:
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this package; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
#

=head1 NAME

mupe - MUltiPath Estimator

=head1 SYNOPSIS

mupe <options>

 Options:
   -d <xdim,ydim>                  image dimension (default: 3,2)
   -f <output format>              image output format (default: png)
   -i <file.pcap>                  pcap input file (required)
   -l <linetype>                   linetype (default: points pt 1)
   -s <BSSID subst>                perl regex subst on BSSIDs (default: s/.$/0/)
   -t <time>                       timeslot size in seconds (default: 2)

   --help                          brief help message

=head1 OPTIONS

=over 8

=item B<-d <xdim,ydim>>

Image dimension used to plot the charts (default: I<3,2>).

=item B<-f <output format>>

Image output format as png, pdf, ps etc. - see gnuplot(1) (default: I<png>).

=item B<-i <file.pcap>>

Input pcap file with Radiotap headers.

=item B<-l <linetype>>

Linetype to plot signal lines, see gnuplot(1) (default: I<points pt 1>).

=item B<-s <BSSID subst>>

Perl regex to apply on BSSID hex strings before processing, the default value zeros the last nibble (default: I<s/.$/0/>).

=item B<-t <time>>

Sets timeslot size in seconds (default: I<2>).

=item B<--help>

Print a brief help message and exits.


=back

=head1 DESCRIPTION

=cut

use strict;
use warnings;
use Getopt::Std;
use Pod::Usage;
use Net::Pcap;
use Chart::Gnuplot;
use Statistics::Descriptive;
use POSIX;
use List::Util qw(min max sum);
use File::Basename;
use Template;

$|++;

use constant {
    # Taken from wireshark 1.3.4 (epan/dissectors/packet-radiotap.c)
    IEEE80211_RADIOTAP_TSFT => 0,
    IEEE80211_RADIOTAP_FLAGS => 1,
    IEEE80211_RADIOTAP_RATE => 2,
    IEEE80211_RADIOTAP_CHANNEL => 3,
    IEEE80211_RADIOTAP_FHSS => 4,
    IEEE80211_RADIOTAP_DBM_ANTSIGNAL => 5,
    IEEE80211_RADIOTAP_DBM_ANTNOISE => 6,
    IEEE80211_RADIOTAP_LOCK_QUALITY => 7,
    IEEE80211_RADIOTAP_TX_ATTENUATION => 8,
    IEEE80211_RADIOTAP_DB_TX_ATTENUATION => 9,
    IEEE80211_RADIOTAP_DBM_TX_POWER => 10,
    IEEE80211_RADIOTAP_ANTENNA => 11,
    IEEE80211_RADIOTAP_DB_ANTSIGNAL => 12,
    IEEE80211_RADIOTAP_DB_ANTNOISE => 13,
    IEEE80211_RADIOTAP_RX_FLAGS => 14,
    IEEE80211_RADIOTAP_XCHANNEL => 18,
    IEEE80211_RADIOTAP_EXT => 31,
};

my %IEEE80211_RADIOTAP_FIELDLEN = (
    0 => 8,
    1 => 1,
    2 => 1,
    3 => 4,
    4 => 2,
    5 => 1,
    6 => 1,
);

# 802.11a/b/g freq => channel map
my %IEEE80211_CHANNELS = (
    # 802.11b/g
    2412 => 1,
    2417 => 2,
    2422 => 3,
    2427 => 4,
    2432 => 5,
    2437 => 6,
    2442 => 7,
    2447 => 8,
    2452 => 9,
    2457 => 10,
    2462 => 11,
    2467 => 12,
    2472 => 13,
    2484 => 14,
    # 802.11a
    5180 => 36,
    5200 => 40,
    5220 => 44,
    5240 => 48,
    5260 => 52,
    5280 => 56,
    5300 => 60,
    5320 => 64,
    5500 => 100,
    5520 => 104,
    5540 => 108,
    5560 => 112,
    5580 => 116,
    5600 => 120,
    5620 => 124,
    5640 => 128,
    5660 => 132,
    5680 => 136,
    5700 => 140,
    5735 => 147,
    5755 => 151,
    5775 => 155,
    5795 => 159,
    5815 => 163,
    5835 => 167,
    5855 => 171,
);

my $logo = <<LOGO;
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
LOGO

my %opts;
getopts('d:f:s:l:t:i:', \%opts);

HELP_MESSAGE() unless(defined($opts{'i'}));

$opts{'l'} = 'points pt 1' unless(defined($opts{'l'}));
$opts{'s'} = 's/.$/0/' unless(defined($opts{'s'}));
$opts{'f'} = 'png' unless(defined($opts{'f'}));
$opts{'d'} = '3,2' unless(defined($opts{'d'}) && $opts{'d'} =~ /^(\d+),(\d+)$/);

my $min_samples = 10;
my @colors = qw(brown green blue);

sub HELP_MESSAGE {
    pod2usage(1);
}

my $tfactor = 2;
if(defined($opts{'t'})) {
    $! = 0;
    ($tfactor) = POSIX::strtod($opts{'t'});

    die "Timeslot size must be float and greater than zero!\n" unless($tfactor > 0 && $! == 0);
}

my $pcap_t;
my $err;
my %warnings;

$pcap_t = Net::Pcap::open_offline($opts{'i'}, \$err);
die "Could not open libpcap: $err\n" unless(defined($pcap_t));

$opts{'i'} = basename($opts{'i'});

my $last_tsamp = 0;
my %beacons;
my %stas;
my %probes;

sub track_beacon {
    my ($tstamp, $bssid, $freq, $bssid2, $ts, $bi) = @_;

    if(exists($beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2})) {
	my $sc = $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2};

	# tolerate up to 0.03% clock deviation
	my $d = $bi/1000000;
	while($sc->{'tstamp'} + $d < $tstamp - $bi*3e-8) {
	    $d += $bi/1000000;
	
	    $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2} = Statistics::Descriptive::Full->new()
		unless(exists($beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}));
	    $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}->add_data($sc->{'tstamp'} + $d);
	}

	$warnings{'beacons'}->{$bssid}->{"Changed beacon interval from $beacons{$freq}->{$bssid}->{beacon}->{$bssid2}->{bi} to ${bi}µs."}++ if($beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'bi'} != $bi);
    }
    else {
	$beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'bi'} = $bi;
    }

    push(@{$beacons{$freq}->{$bssid}->{'beacons'}->{$bssid2}}, $tstamp);
    $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'tstamp'} = $tstamp;
    $beacons{$freq}->{$bssid}->{'beacon'}->{$bssid2}->{'ts'} = $ts;
}

sub push_beacon {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    my ($tstamp, $bssid, $freq, $bssid2, $signal) = @_;

    unless(exists($beacons{$freq}->{$bssid}->{'tstamps'})) {
	$beacons{$freq}->{$bssid}->{'tstamps'} = Statistics::Descriptive::Full->new();
	$beacons{$freq}->{$bssid}->{'signals'} = Statistics::Descriptive::Full->new();
    }

    $beacons{$freq}->{$bssid}->{'tstamps'} -> add_data($tstamp);
    $beacons{$freq}->{$bssid}->{'signals'} -> add_data($signal);

    $beacons{$freq}->{$bssid}->{'counter'} -> {$bssid2}++;
}

sub push_probreq {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    my ($tstamp, $src, $freq, $signal) = @_;

    $probes{$src}->{$freq}->{'req'}->{$tstamp} = $signal;
}

sub push_probres {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    my ($tstamp, $bssid, $freq, $bssid2, $dst, $signal) = @_;

    $probes{$dst}->{$freq}->{'resp'}->{$bssid2}->{$tstamp} = $signal;
}

sub push_data {
    die "Oops, timestamps are not linear!\n" unless($last_tsamp <= $_[0]);
    $last_tsamp = $_[0];

    my ($tstamp, $src, $rt_frequency, $bssid, $rt_ssi_signal) = @_;

    unless(exists($stas{$src}->{$rt_frequency}->{$bssid})) {
	$stas{$src}->{$rt_frequency}->{$bssid}->{'tstamps'} = Statistics::Descriptive::Full->new();
	$stas{$src}->{$rt_frequency}->{$bssid}->{'signals'} = Statistics::Descriptive::Full->new();
    }

    $stas{$src}->{$rt_frequency}->{$bssid}->{'tstamps'} -> add_data($tstamp);
    $stas{$src}->{$rt_frequency}->{$bssid}->{'signals'} -> add_data($rt_ssi_signal);
}

sub process_pkt {
    my($arg, $hdr, $pkt) = @_;

    # decode Radiotap header
    my ($it_version, $it_pad, $it_len, $it_present) = unpack('CCSL', $pkt);
    my $offset = 8;
    my $it_presence = $it_present;

    my $rt_frequency;
    my $rt_ssi_signal;
    my $rt_ssi_noise;

    while($it_present & (1 << IEEE80211_RADIOTAP_EXT)) {
	$it_present = unpack('L', substr($pkt, $offset));
	$it_presence |= $it_present << 32 * ($offset-4)/4;
	$offset += 4;
    }

    ### XXX crude hack XXX ###
    foreach my $fkey (sort keys %IEEE80211_RADIOTAP_FIELDLEN) {
	if(($fkey == IEEE80211_RADIOTAP_CHANNEL) && ($it_presence & (1 << $fkey))) {
	    $rt_frequency = unpack('v', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTSIGNAL) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_signal = unpack('c', substr($pkt, $offset));
	}
	elsif(($fkey == IEEE80211_RADIOTAP_DBM_ANTNOISE) && ($it_presence & (1 << $fkey))) {
	    $rt_ssi_noise = unpack('c', substr($pkt, $offset));
	}

	if($it_presence & (1 << $fkey)) {
	    $offset += $IEEE80211_RADIOTAP_FIELDLEN{$fkey};
	}
    }
    ### XXX /crude hack XXX ###

    # decode IEEE 802.11 Beacon frame
    my ($type, $flags, $duration, $dst, $src, $bssid) = unpack('CCna6a6a6v', substr($pkt, $it_len));

    my $tstamp = $hdr->{tv_sec}+$hdr->{tv_usec}/1000000;

    $dst = unpack('H12', $dst);
    $src = unpack('H12', $src);
    $bssid = unpack('H12', $bssid);

    $dst =~ s/^(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})$/$1$2.$3$4.$5$6/;
    $src =~ s/^(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})$/$1$2.$3$4.$5$6/;
    $bssid =~ s/^(.{2})(.{2})(.{2})(.{2})(.{2})(.{2})$/$1$2.$3$4.$5$6/;

    # beacon frame
    if($type == 0x80) {
	my ($ts_low, $ts_high, $bi) = unpack('VVv', substr($pkt, $it_len + 0x18));
	my $ts = $ts_high << 32 | $ts_low;
	$bi *= 1024;

	$warnings{'beacons'}->{$bssid}->{"Unexpected dst=$dst in beacon of bssid=$bssid!"}++ unless($dst eq 'ffff.ffff.ffff');
	$warnings{'beacons'}->{$bssid}->{"Unexpected src!=bssid ($src!=$bssid) in beacon!"}++ unless($src eq $bssid);

	my $bssid2 = $bssid;
	eval("\$bssid =~ $opts{'s'};") if(defined($opts{'s'}) && $opts{'s'});

	track_beacon($tstamp, $bssid, $rt_frequency, $bssid2, $ts, $bi);
	push_beacon($tstamp, $bssid, $rt_frequency, $bssid2, $rt_ssi_signal);

	print "b";
    }
    # probe request frame
    elsif($type == 0x40) {
	push_probreq($tstamp, $src, $rt_frequency, $rt_ssi_signal);

	print "p";
    }
    # probe response frame
    elsif($type == 0x50) {
	my ($ts_low, $ts_high, $bi) = unpack('VVv', substr($pkt, $it_len + 0x18));
	my $ts = $ts_high << 32 | $ts_low;
	$bi *= 1024;

	$warnings{'beacons'}->{$bssid}->{"Unexpected src!=bssid ($src!=$bssid) in beacon!"}++ unless($src eq $bssid);

	my $bssid2 = $bssid;
	eval("\$bssid =~ $opts{'s'};") if(defined($opts{'s'}) && $opts{'s'});

	$warnings{'beacons'}->{$bssid}->{"Changed beacon interval from $beacons{$rt_frequency}->{$bssid}->{beacon}->{$bssid2}->{bi} to ${bi}µs."}++
	    if(exists($beacons{$rt_frequency}->{$bssid}->{'beacon'}->{$bssid2}) && ($beacons{$rt_frequency}->{$bssid}->{'beacon'}->{$bssid2}->{'bi'} != $bi));

	push_probres($tstamp, $bssid, $rt_frequency, $bssid2, $dst, $rt_ssi_signal);

	print "r";
    }
    # data frame
    elsif(($type & 0x0f) == 8 && !($src =~ /0[01]00\.0000\.0000/)) {
	push_data($tstamp, $src, $rt_frequency, $bssid, $rt_ssi_signal);

	print "d";
    }
}

# Process packets
print "Reading pcap file:\n";
Net::Pcap::loop($pcap_t, -1, \&process_pkt, 0);
print "\n";

sub write_stats {
    my ($fh, $name, $sd) = @_;

    printf $fh "%24s = %s\n", "MEAN($name)", $sd->mean();
    printf $fh "%24s = %s\n", "VAR($name)", $sd->variance();
    printf $fh "%24s = %s\n", "STDDEV($name)", $sd->standard_deviation();
    printf $fh "%24s = %s\n", "MODE($name)", $sd->mode()
     if(defined($sd->mode()));
    printf $fh "%24s = %s\n", "Q0($name)", $sd->quantile(0);
    printf $fh "%24s = %s\n", "Q1($name)", $sd->quantile(1);
    printf $fh "%24s = %s\n", "Q2($name)", $sd->quantile(2);
    printf $fh "%24s = %s\n", "Q3($name)", $sd->quantile(3);
    printf $fh "%24s = %s\n", "Q4($name)", $sd->quantile(4);
    printf $fh "%24s = %s\n", "SKEWNESS($name)", $sd->skewness()
     if(defined($sd->skewness()));
    printf $fh "%24s = %s\n", "KURTOSIS($name)", $sd->kurtosis()
     if(defined($sd->kurtosis()));
    print $fh "\n";
}

sub build_trend_jitter {
    my ($tfn, $subtitle, $data) = @_;

    my $fn = sprintf $tfn, 'signal-trend', $opts{'f'};
    unlink($fn);

    my %trend;
    my @tslots;
    my $i = -1;
    foreach my $tstamp ($data->{'tstamps'}->get_data()) {
	$i++;
	my $t = int($tstamp) - (int($tstamp) % $tfactor);
	push(@tslots, $t) unless($#tslots >= 0 && $tslots[$#tslots] == $t);

	$trend{'signals'}->{$t} = Statistics::Descriptive::Full->new() unless(exists($trend{'signals'}->{$t}));
	$trend{'signals'}->{$t}->add_data(${$data->{'signals'}->{'data'}}[$i]);
    }

    my @ds;
    my %data = (
	'min' => 'MIN(signal)',
	'mean' => 'MEAN(signal)',
	'max' => 'MAX(signal)',
    );

    my %ydata;
    my $sr = Statistics::Descriptive::Full->new();
    foreach my $t (@tslots) {
	foreach my $col (sort keys %data) {
	    push(@{$ydata{$col}}, $trend{'signals'}->{$t}->$col);
	}

	$sr -> add_data($trend{'signals'}->{$t}->sample_range());
    }

    open(HD, sprintf ">$tfn", 'signal-trend', 'txt');
    &write_stats(*HD, 'signal', $data->{'signals'});
    foreach my $col (sort keys %data) {
	my $color = shift(@colors);
	push(@colors, $color);

	my $stat = Statistics::Descriptive::Full->new();
	$stat -> add_data(@{$ydata{$col}});

	&write_stats(*HD, $data{$col}, $stat);
	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => $ydata{$col},
		style => $opts{'l'},
		linetype => 1,
		color => $color,
		title => $data{$col},
		using => '1:2'
	    ),
	    Chart::Gnuplot::DataSet->new(
		func => $stat->mean(),
		style => 'lines',
		linetype => 3,
		color => $color,
		title => "MEAN[$data{$col}]",
		width => 5,
	    ),
	);
    }
    close(HD);

    Chart::Gnuplot->new(
	output => $fn,
	title => "beacon frame signal trend\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dBm',
	imagesize => $opts{'d'},
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(@ds);


    $fn = sprintf $tfn, 'signal-jitter', $opts{'f'};
    unlink($fn);
    my @sr = $sr->get_data();
    Chart::Gnuplot->new(
	output => $fn,
	title => "beacon frame signal jitter\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dB',
	imagesize => $opts{'d'},
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@tslots,
	    ydata => \@sr,
	    style => $opts{'l'},
	    linetype => 1,
	    color => 'red',
	    title => 'SR(signal)',
	    using => '1:2'
	),
	Chart::Gnuplot::DataSet->new(
	    func => $sr->mean(),
	    style => 'lines',
	    linetype => 2,
	    color => 'red',
	    title => "MEAN[SR(signal)]",
	    width => 5,
	),
    );
    open(HD, sprintf ">$tfn", 'signal-jitter', 'txt');
    &write_stats(*HD, 'jitter', $sr);
    close(HD);

    return (
	'beacon frame signal trend' => {
	    'img' => sprintf($tfn, 'signal-trend', $opts{'f'}),
	    'txt' => sprintf($tfn, 'signal-trend', 'txt'),
	},
	'beacon frame signal jitter' => {
	    'img' => sprintf($tfn, 'signal-jitter', $opts{'f'}),
	    'txt' => sprintf($tfn, 'signal-jitter', 'txt'),
	},
    );
}

sub build_distri {
    my ($tfn, $subtitle, $data) = @_;

    ### Signal Distribution ###
    my %distri_signals;
    foreach my $signal ($data->{'signals'}->get_data()) {
	$distri_signals{$signal}++;
    }

    open(HDISTRI, sprintf(">$tfn", 'signal-distri', 'txt')) || die "Could not open file: $?\n";
    print HDISTRI "#signal (dBm), count\n";
    my @distri_signal;
    my @distri_scount;
    foreach my $signal (sort {$a <=> $b} keys %distri_signals) {
	print HDISTRI "$signal, $distri_signals{$signal}\n";
	push(@distri_signal, $signal);
	push(@distri_scount, $distri_signals{$signal}*100/$data->{'signals'}->count());
    }
    close(HDISTRI);

    my $fn = sprintf $tfn, 'signal-distri', $opts{'f'};
    unlink($fn);
    Chart::Gnuplot->new(
	output => $fn,
	title => "beacon frame signal distribution\\n$subtitle",
	xlabel => 'dBm',
	ylabel => '%',
	xtics => \@distri_signal,
	xrange => [-96,-20],
	yrange => [0,100],
	imagesize => $opts{'d'},
	grid => {
	    width => 1.
	},
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@distri_signal,
	    ydata => \@distri_scount,
	    style => 'boxes',
	    fill => '1 border -1',
	    linetype => 1,
	    using => '1:2'
	)
    );

    return (
	'beacon frame signal distribution' => {
	    'img' => sprintf($tfn, 'signal-distri', $opts{'f'}),
	    'txt' => sprintf($tfn, 'signal-distri', 'txt'),
	},
    );
}

sub build_losses {
    my ($tfn, $subtitle, $data) = @_;

    ### Beacon Losses ###
    my @ds;
    open(HD, sprintf ">$tfn", 'beacon-losses', 'txt');
    my @bssid2 = sort keys %{$data->{'losses'}};
    my %res;
    $res{"beacon frame losses"}->{'txt'} = sprintf($tfn, 'beacon-losses', 'txt');
    foreach my $bssid2 (@bssid2) {
	print HD "$bssid2\n";
	print HD " # beacons = ".$data->{'counter'}->{$bssid2}."\n";
	print HD " # missing = ".$data->{'losses'}->{$bssid2}->count()."\n";
	printf HD " loss rate = %.2f%%\n\n", (($data->{'losses'}->{$bssid2}->count() + $data->{'counter'}->{$bssid2}) * 100 / $data->{'counter'}->{$bssid2});

	my %data;
	foreach my $ts ($data->{'losses'}->{$bssid2}->get_data()) {
	    $data{ int($ts) - (int($ts) % $tfactor) }++;
	}

	my %bdata;
	foreach my $ts (@{$data->{'beacons'}->{$bssid2}}) {
	    $bdata{ int($ts) - (int($ts) % $tfactor) }++;
	}

	my @tslots;
	my @losses;
	my @beacons;
	foreach my $tstamp ($data->{'tstamps'}->get_data()) {
	    my $ts = int($tstamp) - (int($tstamp) % $tfactor);

	    unless($#tslots >= 0 && $tslots[$#tslots] == $ts) {
		push(@tslots, $ts) ;
		if(exists($data{$ts})) {
		    push(@losses, $data{$ts});
		}
		else {
		    push(@losses, 0);
		}

		if(exists($bdata{$ts})) {
		    push(@beacons, $bdata{$ts});
		}
		else {
		    push(@beacons, 0);
		}
	    }
        }

	my $fn = sprintf $tfn, "beacon-losses.$bssid2", $opts{'f'};
	unlink($fn);
	Chart::Gnuplot->new(
	    output => $fn,
	    title => "beacon frame losses\\n$subtitle",
	    xlabel => 'timeslot',
#		xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	    imagesize => $opts{'d'},
	    grid => {
		width => 1.
	    },
	    timefmt => '"%s"',
	    xdata => 'time',
	    bg => 'white',
	)->plot2d(
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => \@losses,
		style => 'impulses',
		width => 5,
		linetype => 1,
		color => 'red',
		title => "losses $bssid2",
		using => '1:2',
	    ),
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => \@beacons,
		style => 'lines',
		width => 3,
		linetype => 1,
		color => 'dark-green',
		title => "beacons $bssid2",
		using => '1:2',
		axes => 'x1y2',
	    ),
	);

	$res{"beacon frame losses [$bssid2]"}->{'img'} = $fn;
    }
    close(HD);

    return %res;
}


sub build_sta_trend_jitter {
    my ($tfn, $subtitle, $data) = @_;

    my $fn = sprintf $tfn, 'signal-trend', $opts{'f'};
    unlink($fn);

    my %trend;
    my @tslots;
    my $sc = Statistics::Descriptive::Full->new();
    foreach my $freq (keys %{$data}) {
	foreach my $bssid (keys %{$data->{$freq}}) {
	    my $i = -1;

	    $sc->add_data(@{$data->{$freq}->{$bssid}->{'signals'}->{'data'}});
	    foreach my $tstamp ($data->{$freq}->{$bssid}->{'tstamps'}->get_data()) {
		$i++;
		my $t = int($tstamp) - (int($tstamp) % $tfactor);
		push(@tslots, $t) unless($#tslots >= 0 && $tslots[$#tslots] == $t);

		$trend{'signals'}->{$t} = Statistics::Descriptive::Full->new() unless(exists($trend{'signals'}->{$t}));
		$trend{'signals'}->{$t}->add_data(${$data->{$freq}->{$bssid}->{'signals'}->{'data'}}[$i]);
	    }
	}
    }

    if($sc->count() < $min_samples) {
	print "  ignoring - less than $min_samples samples\n";
	return ();
    }

    my @ds;
    my %data = (
	'min' => 'MIN(signal)',
	'mean' => 'MEAN(signal)',
	'max' => 'MAX(signal)',
    );

    my %ydata;
    my $sr = Statistics::Descriptive::Full->new();
    foreach my $t (@tslots) {
	foreach my $col (sort keys %data) {
	    push(@{$ydata{$col}}, $trend{'signals'}->{$t}->$col);
	}

	$sr -> add_data($trend{'signals'}->{$t}->sample_range());
    }

    open(HD, sprintf ">$tfn", 'signal-trend', 'txt');
    &write_stats(*HD, 'signal', $sc);
    foreach my $col (sort keys %data) {
	my $color = shift(@colors);
	push(@colors, $color);

	my $stat = Statistics::Descriptive::Full->new();
	$stat -> add_data(@{$ydata{$col}});

	&write_stats(*HD, $data{$col}, $stat);
	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => $ydata{$col},
		style => $opts{'l'},
		linetype => 1,
		color => $color,
		title => $data{$col},
		using => '1:2'
	    ),
	    Chart::Gnuplot::DataSet->new(
		func => $stat->mean(),
		style => 'lines',
		linetype => 3,
		color => $color,
		title => "MEAN[$data{$col}]",
		width => 5,
	    ),
	);
    }
    close(HD);

    Chart::Gnuplot->new(
	output => $fn,
	title => "data frame signal trend\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dBm',
	imagesize => $opts{'d'},
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(@ds);


    $fn = sprintf $tfn, 'signal-jitter', $opts{'f'};
    unlink($fn);
    my @sr = $sr->get_data();
    Chart::Gnuplot->new(
	output => $fn,
	title => "data frame signal jitter\\n$subtitle",
	xlabel => 'timeslot',
#	xrange => [$data->{'tstamps'}->min(), $data->{'tstamps'}->max()],
	ylabel => 'dB',
	imagesize => $opts{'d'},
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@tslots,
	    ydata => \@sr,
	    style => $opts{'l'},
	    linetype => 1,
	    color => 'red',
	    title => 'SR(signal)',
	    using => '1:2'
	),
	Chart::Gnuplot::DataSet->new(
	    func => $sr->mean(),
	    style => 'lines',
	    linetype => 2,
	    color => 'red',
	    title => "MEAN[SR(signal)]",
	    width => 5,
	),
    );
    open(HD, sprintf ">$tfn", 'signal-jitter', 'txt');
    &write_stats(*HD, 'jitter', $sr);
    close(HD);

    return (
	'data frame signal trend' => {
	    'img' => sprintf($tfn, 'signal-trend', $opts{'f'}),
	    'txt' => sprintf($tfn, 'signal-trend', 'txt'),
	},
	'data frame signal jitter' => {
	    'img' => sprintf($tfn, 'signal-jitter', $opts{'f'}),
	    'txt' => sprintf($tfn, 'signal-jitter', 'txt'),
	},
    );
}

sub build_sta_distri {
    my ($tfn, $subtitle, $data) = @_;

    ### STA Signal Distribution ###
    my %distri_signals;
    my $count;
    foreach my $freq (keys %{$data}) {
	foreach my $bssid (keys %{$data->{$freq}}) {
	    foreach my $signal ($data->{$freq}->{$bssid}->{'signals'}->get_data()) {
		$distri_signals{$signal}++;
		$count++;
	    }
	}
    }

    return () if($count < $min_samples);

    open(HDISTRI, sprintf(">$tfn", 'signal-distri', 'txt')) || die "Could not open file: $?\n";
    print HDISTRI "#signal (dBm), count\n";
    my @distri_signal;
    my @distri_scount;
    foreach my $signal (sort {$a <=> $b} keys %distri_signals) {
	print HDISTRI "$signal, $distri_signals{$signal}\n";
	push(@distri_signal, $signal);
	push(@distri_scount, $distri_signals{$signal}*100/$count);
    }
    close(HDISTRI);

    my $fn = sprintf $tfn, 'signal-distri', $opts{'f'};
    unlink($fn);
    Chart::Gnuplot->new(
	output => $fn,
	title => "data frame signal distribution\\n$subtitle",
	xlabel => 'dBm',
	ylabel => '%',
	xtics => \@distri_signal,
	xrange => [-96,-20],
	yrange => [0,100],
	imagesize => $opts{'d'},
	grid => {
	    width => 1.
	},
	bg => 'white',
    )->plot2d(
	Chart::Gnuplot::DataSet->new(
	    xdata => \@distri_signal,
	    ydata => \@distri_scount,
	    style => 'boxes',
	    fill => '1 border -1',
	    linetype => 1,
	    using => '1:2'
	)
    );

    return (
	'signal-distri' => 'data frame signal distribution',
    );
}

sub build_probes($$$) {
    my ($tfn, $subtitle, $data) = @_;

    my $fn = sprintf $tfn, 'probe-pattern', $opts{'f'};
    unlink($fn);

    my %tslots;
    my %reqs;
    foreach my $freq (sort {$a <=> $b} keys %{$data}) {
	my $i = -1;
	foreach my $tstamp (keys %{$data->{$freq}->{'req'}}) {

	    $i++;
	    my $t = int($tstamp) - (int($tstamp) % $tfactor);
	    $tslots{$t} = 1;
	    $reqs{$freq}->{$t}++;
	}
    }

    my @ds;
    my @tslots = sort {$a <=> $b} keys %tslots;
    my %ztics;
    foreach my $freq (sort {$a <=> $b} keys %reqs) {
	my @freqs;
	my @reqs;

	foreach my $ts (@tslots) {
	    push(@freqs, $freq);
	    if(defined($reqs{$freq}->{$ts})) {
		push(@reqs, $reqs{$freq}->{$ts});
		$ztics{$reqs{$freq}->{$ts}} = 1;
	    }
	    else {
		push(@reqs, 0);
	    }
	}

	push(@ds,
	    Chart::Gnuplot::DataSet->new(
		xdata => \@tslots,
		ydata => \@freqs,
		zdata => \@reqs,
		style => "points pt 1 ps 3 palette",
		using => '1:2:3'
	    ),
	);
    }

    if($#ds == -1) {
	print "  ignoring - no data\n";
	return ()
    }

    my @ytics = sort {$a <=> $b} keys %IEEE80211_CHANNELS;
    my @ztics = sort {$a <=> $b} keys %ztics;

    Chart::Gnuplot->new(
	output => $fn,
	title => "probe request count pattern\\n$subtitle",
	xlabel => 'timeslot',
	ylabel => 'MHz',
	ytics => \@ytics,
	ztics => \@ztics,
	imagesize => $opts{'d'},
	grid => {
	    width => 1.
	},
	timefmt => '"%s"',
	xdata => 'time',
	bg => 'white',
	view => 'map',
	palette => 'rgbformulae -8,-6,0',
    )->plot3d(@ds);

    return (
	'probe request count pattern' => {
	    'img' => sprintf($tfn, 'probe-pattern', $opts{'f'}),
	    'txt' => sprintf($tfn, 'probe-pattern', 'txt'),
	},
    );
}


my %links;

print "\nGenerating beacon frame graphs:\n";
foreach my $freq (keys %beacons) {
    foreach my $bssid (sort keys %{$beacons{$freq}}) {
	my $count = $beacons{$freq}->{$bssid}->{'tstamps'}->{'count'};
	my $ts_min = $beacons{$freq}->{$bssid}->{'tstamps'}->{'min'};
	my $ts_max = $beacons{$freq}->{$bssid}->{'tstamps'}->{'max'};

	if($count < $min_samples) {
	    print " ignoring BSSID $bssid @ ${freq}MHz - less than $min_samples samples\n";
	    print STDERR join("\n", keys %{$warnings{'beacons'}->{$bssid}})
		if(exists($warnings{'beacons'}->{$bssid}));
	    next;
	}

	print " BSSID $bssid @ $freq MHz\n";
	print STDERR join("\n", keys %{$warnings{'beacons'}->{$bssid}})
	    if(exists($warnings{'beacons'}->{$bssid}));
	foreach my $bssid2 (sort keys %{$beacons{$freq}->{$bssid}->{'counter'}}) {
	    print "  $bssid2 has $beacons{$freq}->{$bssid}->{counter}->{$bssid2}";
	    print " (", $beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}->count()," lost)"
		if(exists($beacons{$freq}->{$bssid}->{'losses'}->{$bssid2}));
	    print " beacons\n";
	}

	my $tfn = $opts{'i'};
	$tfn =~ s/\.pcap$//;
	$tfn .= ".BSSID-$bssid-${freq}MHz.%s.%s";
	my $subtitle = "$opts{i} [BSSID = $bssid, f = ${freq}MHz, tslot = ${tfactor}s]";

	my %l = (
	    build_trend_jitter($tfn, $subtitle, $beacons{$freq} -> {$bssid}),
	    build_distri($tfn, $subtitle,  $beacons{$freq} -> {$bssid}),
	    build_losses($tfn, $subtitle,  $beacons{$freq} -> {$bssid}),
	);

	$links{'beacons'}->{$freq}->{$bssid} = \%l;
    }
}

print "\nGenerating data frame graphs:\n";
foreach my $src (sort keys %stas) {
    print " STA $src\n";

    my $tfn = $opts{'i'};
    $tfn =~ s/\.pcap$//;
    $tfn .= ".STA-$src.%s.%s";
    my $subtitle = "$opts{i} [STA = $src, tslot = ${tfactor}s]";

    my %l = (
	build_sta_trend_jitter($tfn, $subtitle, $stas{$src}),
	build_sta_distri($tfn, $subtitle, $stas{$src}),
    );

    $links{'data'}->{$src} = \%l;
}

print "\nGenerating probe pattern graphs:\n";
foreach my $src (sort keys %probes) {
    print " STA $src\n";

    my $tfn = $opts{'i'};
    $tfn =~ s/\.pcap$//;
    $tfn .= ".STA-$src.%s.%s";
    my $subtitle = "$opts{i} [STA = $src, tslot = ${tfactor}s]";

    my %l = (
	build_probes($tfn, $subtitle, $probes{$src}),
    );

    $links{'probes'}->{$src} = \%l;
}

print "\nCreating result HTML page:\n";

unless(-e 'mupe.png') {
    use MIME::Base64;
    open(HLOGO, '>mupe.png');
    print HLOGO decode_base64($logo);
    close(HLOGO);
}

my $fn = $opts{'i'};
$fn =~ s/\.pcap$//;
$fn .= ".html";

open(HHTML, ">$fn") || die "Could not open output file '$fn': $!\n";

my $tt = Template->new(
    POST_CHOMP => 1,
    EVAL_PERL => 1,
) || die $Template::ERROR, "\n";
$tt->process(
    \*DATA,
    {
	'fn' => $opts{'i'},
	'links' => \%links,
    },
    \*HHTML
) || die $tt->error(), "\n";
print " $fn\n\n";

__DATA__
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<html>
<header>
<title>[mupe] [% fn %]</title>
<script language="javascript"> 
    function toggle(elName) {
	var ele = document.getElementById(elName);
	if(ele.style.display == "block") {
	    ele.style.display = "none";
	}
	else {
	    ele.style.display = "block";
	}
}
</script>
</header>
<body>
<div style="margin-bottom:6px;>
    <img src="mupe.png" height="64" width="64" alt="mupe logo" style="float: left; margin-right: 15px;"/>
    <h1>[% fn %]</h1>
</div>
[% BLOCK link %]
<li>
    <a href="javascript:toggle('[% id %]');">[% title %]</a>
    <div id="[% id %]" style="display: none;">
[% IF img %]
	<p>
	    <a href="[% img %]">
		<img src="[% img %]" alt="[% title %]" border="0" height="80%" width="80%"/>
	    </a>
	</p>
[% END %]
[% IF content %]
	<pre>
[% content %]
	</pre>
[% END %]
    </div>
</li>
[% END %]

[% PERL %]

if(keys %{$stash->get('links')->{'beacons'}}) {
    print "<h2>Beacon frame graphs</h2>\n";

    foreach my $freq (keys %{$stash->get('links')->{'beacons'}}) {
	foreach my $bssid (keys %{$stash->get('links')->{'beacons'}->{$freq}}) {
	    print "<h3>$bssid</h3>\n";
	    print "<ul>\n";

	    foreach my $k (sort {$a cmp $b} keys %{$stash->get('links')->{'beacons'}->{$freq}->{$bssid}}) {
		my $links = $stash->get('links')->{'beacons'}->{$freq}->{$bssid}->{$k};

		my $content = '';
		if (exists($links->{'txt'}) && open(HPRE, $links->{'txt'})) {
		    $content = join('', <HPRE>);
		    close(HPRE);
		}

		my $id = $stash->get('id');
		$id = 0 if($id eq '');
		$stash->set('id', $id+1);

                print $context->include('link', {
		    content => $content,
		    id => "id$id",
		    img => $links->{'img'},
		    title => $k,
                });
	    }
	    print "</ul>\n";
	}
    }
}

if(keys %{$stash->get('links')->{'data'}}) {
    print "<h2>Data frame graphs</h2>\n";
    foreach my $src (sort keys %{$stash->get('links')->{'data'}}) {
	print "<h3>$src</h3>\n";
	print "<ul>\n";
	foreach my $k (sort {$a cmp $b} keys %{$stash->get('links')->{'data'}->{$src}}) {
	    my $links = $stash->get('links')->{'data'}->{$src}->{$k};

	    my $content = '';
	    if (exists($links->{'txt'}) && open(HPRE, $links->{'txt'})) {
		$content = join('', <HPRE>);
		close(HPRE);
	    }

	    my $id = $stash->get('id');
	    $id = 0 if($id eq '');
	    $stash->set('id', $id+1);

	    print $context->include('link', {
		content => $content,
		id => "id$id",
		img => $links->{'img'},
		title => $k,
            });
        }
	print "</ul>\n";
    }
}

if(keys %{$stash->get('links')->{'probes'}}) {
    print "<h2>Probe pattern graphs</h2>\n";
    foreach my $src (sort keys %{$stash->get('links')->{'probes'}}) {
	print "<h3>$src</h3>\n";
	print "<ul>\n";
	foreach my $k (sort {$a cmp $b} keys %{$stash->get('links')->{'probes'}->{$src}}) {
	    my $links = $stash->get('links')->{'probes'}->{$src}->{$k};

	    my $content = '';
	    if (exists($links->{'txt'}) && open(HPRE, $links->{'txt'})) {
		$content = join('', <HPRE>);
		close(HPRE);
	    }

	    my $id = $stash->get('id');
	    $id = 0 if($id eq '');
	    $stash->set('id', $id+1);

	    print $context->include('link', {
		content => $content,
		id => "id$id",
		img => $links->{'img'},
		title => $k,
            });
        }
	print "</ul>\n";
    }
}

[% END %]
</body>
</html>
